/* automatically generated by rust-bindgen 0.66.1 */

pub const DUCKDB_API_0_3_1: u32 = 1;
pub const DUCKDB_API_0_3_2: u32 = 2;
pub const DUCKDB_API_LATEST: u32 = 2;
pub const DUCKDB_API_VERSION: u32 = 2;
pub const __bool_true_false_are_defined: u32 = 1;
pub const true_: u32 = 1;
pub const false_: u32 = 0;
pub const __BIONIC__: u32 = 1;
pub const __WORDSIZE: u32 = 64;
pub const __bos_level: u32 = 0;
pub const __ANDROID_API_FUTURE__: u32 = 10000;
pub const __ANDROID_API_G__: u32 = 9;
pub const __ANDROID_API_I__: u32 = 14;
pub const __ANDROID_API_J__: u32 = 16;
pub const __ANDROID_API_J_MR1__: u32 = 17;
pub const __ANDROID_API_J_MR2__: u32 = 18;
pub const __ANDROID_API_K__: u32 = 19;
pub const __ANDROID_API_L__: u32 = 21;
pub const __ANDROID_API_L_MR1__: u32 = 22;
pub const __ANDROID_API_M__: u32 = 23;
pub const __ANDROID_API_N__: u32 = 24;
pub const __ANDROID_API_N_MR1__: u32 = 25;
pub const __ANDROID_API_O__: u32 = 26;
pub const __ANDROID_API_O_MR1__: u32 = 27;
pub const __ANDROID_API_P__: u32 = 28;
pub const __ANDROID_API_Q__: u32 = 29;
pub const __ANDROID_API_R__: u32 = 30;
pub const __ANDROID_API_S__: u32 = 31;
pub const __ANDROID_API_T__: u32 = 33;
pub const __ANDROID_API_U__: u32 = 34;
pub const __ANDROID_NDK__: u32 = 1;
pub const __NDK_MAJOR__: u32 = 25;
pub const __NDK_MINOR__: u32 = 2;
pub const __NDK_BETA__: u32 = 0;
pub const __NDK_BUILD__: u32 = 9519653;
pub const __NDK_CANARY__: u32 = 0;
pub const __TERMUX__: u32 = 1;
pub const __TERMUX_PREFIX__: &[u8; 32] = b"/data/data/com.termux/files/usr\0";
pub const WCHAR_MIN: u8 = 0u8;
pub const INT8_MIN: i32 = -128;
pub const INT8_MAX: u32 = 127;
pub const INT_LEAST8_MIN: i32 = -128;
pub const INT_LEAST8_MAX: u32 = 127;
pub const INT_FAST8_MIN: i32 = -128;
pub const INT_FAST8_MAX: u32 = 127;
pub const UINT8_MAX: u32 = 255;
pub const UINT_LEAST8_MAX: u32 = 255;
pub const UINT_FAST8_MAX: u32 = 255;
pub const INT16_MIN: i32 = -32768;
pub const INT16_MAX: u32 = 32767;
pub const INT_LEAST16_MIN: i32 = -32768;
pub const INT_LEAST16_MAX: u32 = 32767;
pub const UINT16_MAX: u32 = 65535;
pub const UINT_LEAST16_MAX: u32 = 65535;
pub const INT32_MIN: i32 = -2147483648;
pub const INT32_MAX: u32 = 2147483647;
pub const INT_LEAST32_MIN: i32 = -2147483648;
pub const INT_LEAST32_MAX: u32 = 2147483647;
pub const INT_FAST32_MIN: i32 = -2147483648;
pub const INT_FAST32_MAX: u32 = 2147483647;
pub const UINT32_MAX: u32 = 4294967295;
pub const UINT_LEAST32_MAX: u32 = 4294967295;
pub const UINT_FAST32_MAX: u32 = 4294967295;
pub const SIG_ATOMIC_MAX: u32 = 2147483647;
pub const SIG_ATOMIC_MIN: i32 = -2147483648;
pub const WINT_MAX: u32 = 4294967295;
pub const WINT_MIN: u32 = 0;
pub const WNOHANG: u32 = 1;
pub const WUNTRACED: u32 = 2;
pub const WSTOPPED: u32 = 2;
pub const WEXITED: u32 = 4;
pub const WCONTINUED: u32 = 8;
pub const WNOWAIT: u32 = 16777216;
pub const __WNOTHREAD: u32 = 536870912;
pub const __WALL: u32 = 1073741824;
pub const __WCLONE: u32 = 2147483648;
pub const P_ALL: u32 = 0;
pub const P_PID: u32 = 1;
pub const P_PGID: u32 = 2;
pub const P_PIDFD: u32 = 3;
pub const __BITS_PER_LONG: u32 = 64;
pub const __FD_SETSIZE: u32 = 1024;
pub const O_DIRECTORY: u32 = 16384;
pub const O_NOFOLLOW: u32 = 32768;
pub const O_DIRECT: u32 = 65536;
pub const O_LARGEFILE: u32 = 131072;
pub const O_ACCMODE: u32 = 3;
pub const O_RDONLY: u32 = 0;
pub const O_WRONLY: u32 = 1;
pub const O_RDWR: u32 = 2;
pub const O_CREAT: u32 = 64;
pub const O_EXCL: u32 = 128;
pub const O_NOCTTY: u32 = 256;
pub const O_TRUNC: u32 = 512;
pub const O_APPEND: u32 = 1024;
pub const O_NONBLOCK: u32 = 2048;
pub const O_DSYNC: u32 = 4096;
pub const FASYNC: u32 = 8192;
pub const O_NOATIME: u32 = 262144;
pub const O_CLOEXEC: u32 = 524288;
pub const __O_SYNC: u32 = 1048576;
pub const O_SYNC: u32 = 1052672;
pub const O_PATH: u32 = 2097152;
pub const __O_TMPFILE: u32 = 4194304;
pub const O_TMPFILE: u32 = 4210688;
pub const O_TMPFILE_MASK: u32 = 4210752;
pub const O_NDELAY: u32 = 2048;
pub const F_DUPFD: u32 = 0;
pub const F_GETFD: u32 = 1;
pub const F_SETFD: u32 = 2;
pub const F_GETFL: u32 = 3;
pub const F_SETFL: u32 = 4;
pub const F_GETLK: u32 = 5;
pub const F_SETLK: u32 = 6;
pub const F_SETLKW: u32 = 7;
pub const F_SETOWN: u32 = 8;
pub const F_GETOWN: u32 = 9;
pub const F_SETSIG: u32 = 10;
pub const F_GETSIG: u32 = 11;
pub const F_SETOWN_EX: u32 = 15;
pub const F_GETOWN_EX: u32 = 16;
pub const F_GETOWNER_UIDS: u32 = 17;
pub const F_OFD_GETLK: u32 = 36;
pub const F_OFD_SETLK: u32 = 37;
pub const F_OFD_SETLKW: u32 = 38;
pub const F_OWNER_TID: u32 = 0;
pub const F_OWNER_PID: u32 = 1;
pub const F_OWNER_PGRP: u32 = 2;
pub const FD_CLOEXEC: u32 = 1;
pub const F_RDLCK: u32 = 0;
pub const F_WRLCK: u32 = 1;
pub const F_UNLCK: u32 = 2;
pub const F_EXLCK: u32 = 4;
pub const F_SHLCK: u32 = 8;
pub const LOCK_SH: u32 = 1;
pub const LOCK_EX: u32 = 2;
pub const LOCK_NB: u32 = 4;
pub const LOCK_UN: u32 = 8;
pub const LOCK_MAND: u32 = 32;
pub const LOCK_READ: u32 = 64;
pub const LOCK_WRITE: u32 = 128;
pub const LOCK_RW: u32 = 192;
pub const F_LINUX_SPECIFIC_BASE: u32 = 1024;
pub const SEEK_SET: u32 = 0;
pub const SEEK_CUR: u32 = 1;
pub const SEEK_END: u32 = 2;
pub const _IOFBF: u32 = 0;
pub const _IOLBF: u32 = 1;
pub const _IONBF: u32 = 2;
pub const BUFSIZ: u32 = 1024;
pub const EOF: i32 = -1;
pub const FOPEN_MAX: u32 = 20;
pub const FILENAME_MAX: u32 = 4096;
pub const L_tmpnam: u32 = 4096;
pub const TMP_MAX: u32 = 308915776;
pub const P_tmpdir: &[u8; 37] = b"/data/data/com.termux/files/usr/tmp/\0";
pub const L_ctermid: u32 = 1024;
pub const STRUCT_MALLINFO_DECLARED: u32 = 1;
pub const M_DECAY_TIME: i32 = -100;
pub const M_PURGE: i32 = -101;
pub const M_MEMTAG_TUNING: i32 = -102;
pub const M_MEMTAG_TUNING_BUFFER_OVERFLOW: u32 = 0;
pub const M_MEMTAG_TUNING_UAF: u32 = 1;
pub const M_THREAD_DISABLE_MEM_INIT: i32 = -103;
pub const M_CACHE_COUNT_MAX: i32 = -200;
pub const M_CACHE_SIZE_MAX: i32 = -201;
pub const M_TSDS_COUNT_MAX: i32 = -202;
pub const M_BIONIC_ZERO_INIT: i32 = -203;
pub const M_BIONIC_SET_HEAP_TAGGING_LEVEL: i32 = -204;
pub const EXIT_FAILURE: u32 = 1;
pub const EXIT_SUCCESS: u32 = 0;
pub const RAND_MAX: u32 = 2147483647;
pub const MB_CUR_MAX: u32 = 4;
extern "C" {
    pub fn android_get_application_target_sdk_version() -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn __system_property_get(
        __name: *const ::std::os::raw::c_char,
        __value: *mut ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn atoi(__s: *const ::std::os::raw::c_char) -> ::std::os::raw::c_int;
}
pub type wchar_t = ::std::os::raw::c_uint;
#[repr(C)]
#[repr(align(16))]
#[derive(Debug, Copy, Clone)]
pub struct max_align_t {
    pub __clang_max_align_nonce1: ::std::os::raw::c_longlong,
    pub __bindgen_padding_0: u64,
    pub __clang_max_align_nonce2: u128,
}
#[test]
fn bindgen_test_layout_max_align_t() {
    const UNINIT: ::std::mem::MaybeUninit<max_align_t> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<max_align_t>(),
        32usize,
        concat!("Size of: ", stringify!(max_align_t))
    );
    assert_eq!(
        ::std::mem::align_of::<max_align_t>(),
        16usize,
        concat!("Alignment of ", stringify!(max_align_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__clang_max_align_nonce1) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(max_align_t),
            "::",
            stringify!(__clang_max_align_nonce1)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__clang_max_align_nonce2) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(max_align_t),
            "::",
            stringify!(__clang_max_align_nonce2)
        )
    );
}
pub type __int8_t = ::std::os::raw::c_schar;
pub type __uint8_t = ::std::os::raw::c_uchar;
pub type __int16_t = ::std::os::raw::c_short;
pub type __uint16_t = ::std::os::raw::c_ushort;
pub type __int32_t = ::std::os::raw::c_int;
pub type __uint32_t = ::std::os::raw::c_uint;
pub type __int64_t = ::std::os::raw::c_long;
pub type __uint64_t = ::std::os::raw::c_ulong;
pub type __intptr_t = ::std::os::raw::c_long;
pub type __uintptr_t = ::std::os::raw::c_ulong;
pub type int_least8_t = i8;
pub type uint_least8_t = u8;
pub type int_least16_t = i16;
pub type uint_least16_t = u16;
pub type int_least32_t = i32;
pub type uint_least32_t = u32;
pub type int_least64_t = i64;
pub type uint_least64_t = u64;
pub type int_fast8_t = i8;
pub type uint_fast8_t = u8;
pub type int_fast64_t = i64;
pub type uint_fast64_t = u64;
pub type int_fast16_t = i64;
pub type uint_fast16_t = u64;
pub type int_fast32_t = i64;
pub type uint_fast32_t = u64;
pub type uintmax_t = u64;
pub type intmax_t = i64;
pub type __s8 = ::std::os::raw::c_schar;
pub type __u8 = ::std::os::raw::c_uchar;
pub type __s16 = ::std::os::raw::c_short;
pub type __u16 = ::std::os::raw::c_ushort;
pub type __s32 = ::std::os::raw::c_int;
pub type __u32 = ::std::os::raw::c_uint;
pub type __s64 = ::std::os::raw::c_longlong;
pub type __u64 = ::std::os::raw::c_ulonglong;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __kernel_fd_set {
    pub fds_bits: [::std::os::raw::c_ulong; 16usize],
}
#[test]
fn bindgen_test_layout___kernel_fd_set() {
    const UNINIT: ::std::mem::MaybeUninit<__kernel_fd_set> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<__kernel_fd_set>(),
        128usize,
        concat!("Size of: ", stringify!(__kernel_fd_set))
    );
    assert_eq!(
        ::std::mem::align_of::<__kernel_fd_set>(),
        8usize,
        concat!("Alignment of ", stringify!(__kernel_fd_set))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).fds_bits) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__kernel_fd_set),
            "::",
            stringify!(fds_bits)
        )
    );
}
pub type __kernel_sighandler_t = ::std::option::Option<unsafe extern "C" fn(arg1: ::std::os::raw::c_int)>;
pub type __kernel_key_t = ::std::os::raw::c_int;
pub type __kernel_mqd_t = ::std::os::raw::c_int;
pub type __kernel_old_uid_t = ::std::os::raw::c_ushort;
pub type __kernel_old_gid_t = ::std::os::raw::c_ushort;
pub type __kernel_long_t = ::std::os::raw::c_long;
pub type __kernel_ulong_t = ::std::os::raw::c_ulong;
pub type __kernel_ino_t = __kernel_ulong_t;
pub type __kernel_mode_t = ::std::os::raw::c_uint;
pub type __kernel_pid_t = ::std::os::raw::c_int;
pub type __kernel_ipc_pid_t = ::std::os::raw::c_int;
pub type __kernel_uid_t = ::std::os::raw::c_uint;
pub type __kernel_gid_t = ::std::os::raw::c_uint;
pub type __kernel_suseconds_t = __kernel_long_t;
pub type __kernel_daddr_t = ::std::os::raw::c_int;
pub type __kernel_uid32_t = ::std::os::raw::c_uint;
pub type __kernel_gid32_t = ::std::os::raw::c_uint;
pub type __kernel_old_dev_t = ::std::os::raw::c_uint;
pub type __kernel_size_t = __kernel_ulong_t;
pub type __kernel_ssize_t = __kernel_long_t;
pub type __kernel_ptrdiff_t = __kernel_long_t;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __kernel_fsid_t {
    pub val: [::std::os::raw::c_int; 2usize],
}
#[test]
fn bindgen_test_layout___kernel_fsid_t() {
    const UNINIT: ::std::mem::MaybeUninit<__kernel_fsid_t> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<__kernel_fsid_t>(),
        8usize,
        concat!("Size of: ", stringify!(__kernel_fsid_t))
    );
    assert_eq!(
        ::std::mem::align_of::<__kernel_fsid_t>(),
        4usize,
        concat!("Alignment of ", stringify!(__kernel_fsid_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).val) as usize - ptr as usize },
        0usize,
        concat!("Offset of field: ", stringify!(__kernel_fsid_t), "::", stringify!(val))
    );
}
pub type __kernel_off_t = __kernel_long_t;
pub type __kernel_loff_t = ::std::os::raw::c_longlong;
pub type __kernel_old_time_t = __kernel_long_t;
pub type __kernel_time_t = __kernel_long_t;
pub type __kernel_time64_t = ::std::os::raw::c_longlong;
pub type __kernel_clock_t = __kernel_long_t;
pub type __kernel_timer_t = ::std::os::raw::c_int;
pub type __kernel_clockid_t = ::std::os::raw::c_int;
pub type __kernel_caddr_t = *mut ::std::os::raw::c_char;
pub type __kernel_uid16_t = ::std::os::raw::c_ushort;
pub type __kernel_gid16_t = ::std::os::raw::c_ushort;
pub type __le16 = __u16;
pub type __be16 = __u16;
pub type __le32 = __u32;
pub type __be32 = __u32;
pub type __le64 = __u64;
pub type __be64 = __u64;
pub type __sum16 = __u16;
pub type __wsum = __u32;
pub type __poll_t = ::std::os::raw::c_uint;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct pthread_attr_t {
    pub flags: u32,
    pub stack_base: *mut ::std::os::raw::c_void,
    pub stack_size: usize,
    pub guard_size: usize,
    pub sched_policy: i32,
    pub sched_priority: i32,
    pub __reserved: [::std::os::raw::c_char; 16usize],
}
#[test]
fn bindgen_test_layout_pthread_attr_t() {
    const UNINIT: ::std::mem::MaybeUninit<pthread_attr_t> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<pthread_attr_t>(),
        56usize,
        concat!("Size of: ", stringify!(pthread_attr_t))
    );
    assert_eq!(
        ::std::mem::align_of::<pthread_attr_t>(),
        8usize,
        concat!("Alignment of ", stringify!(pthread_attr_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).flags) as usize - ptr as usize },
        0usize,
        concat!("Offset of field: ", stringify!(pthread_attr_t), "::", stringify!(flags))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).stack_base) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_attr_t),
            "::",
            stringify!(stack_base)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).stack_size) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_attr_t),
            "::",
            stringify!(stack_size)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).guard_size) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_attr_t),
            "::",
            stringify!(guard_size)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).sched_policy) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_attr_t),
            "::",
            stringify!(sched_policy)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).sched_priority) as usize - ptr as usize },
        36usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_attr_t),
            "::",
            stringify!(sched_priority)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__reserved) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_attr_t),
            "::",
            stringify!(__reserved)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct pthread_barrier_t {
    pub __private: [i64; 4usize],
}
#[test]
fn bindgen_test_layout_pthread_barrier_t() {
    const UNINIT: ::std::mem::MaybeUninit<pthread_barrier_t> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<pthread_barrier_t>(),
        32usize,
        concat!("Size of: ", stringify!(pthread_barrier_t))
    );
    assert_eq!(
        ::std::mem::align_of::<pthread_barrier_t>(),
        8usize,
        concat!("Alignment of ", stringify!(pthread_barrier_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__private) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_barrier_t),
            "::",
            stringify!(__private)
        )
    );
}
pub type pthread_barrierattr_t = ::std::os::raw::c_int;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct pthread_cond_t {
    pub __private: [i32; 12usize],
}
#[test]
fn bindgen_test_layout_pthread_cond_t() {
    const UNINIT: ::std::mem::MaybeUninit<pthread_cond_t> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<pthread_cond_t>(),
        48usize,
        concat!("Size of: ", stringify!(pthread_cond_t))
    );
    assert_eq!(
        ::std::mem::align_of::<pthread_cond_t>(),
        4usize,
        concat!("Alignment of ", stringify!(pthread_cond_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__private) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_cond_t),
            "::",
            stringify!(__private)
        )
    );
}
pub type pthread_condattr_t = ::std::os::raw::c_long;
pub type pthread_key_t = ::std::os::raw::c_int;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct pthread_mutex_t {
    pub __private: [i32; 10usize],
}
#[test]
fn bindgen_test_layout_pthread_mutex_t() {
    const UNINIT: ::std::mem::MaybeUninit<pthread_mutex_t> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<pthread_mutex_t>(),
        40usize,
        concat!("Size of: ", stringify!(pthread_mutex_t))
    );
    assert_eq!(
        ::std::mem::align_of::<pthread_mutex_t>(),
        4usize,
        concat!("Alignment of ", stringify!(pthread_mutex_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__private) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_mutex_t),
            "::",
            stringify!(__private)
        )
    );
}
pub type pthread_mutexattr_t = ::std::os::raw::c_long;
pub type pthread_once_t = ::std::os::raw::c_int;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct pthread_rwlock_t {
    pub __private: [i32; 14usize],
}
#[test]
fn bindgen_test_layout_pthread_rwlock_t() {
    const UNINIT: ::std::mem::MaybeUninit<pthread_rwlock_t> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<pthread_rwlock_t>(),
        56usize,
        concat!("Size of: ", stringify!(pthread_rwlock_t))
    );
    assert_eq!(
        ::std::mem::align_of::<pthread_rwlock_t>(),
        4usize,
        concat!("Alignment of ", stringify!(pthread_rwlock_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__private) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_rwlock_t),
            "::",
            stringify!(__private)
        )
    );
}
pub type pthread_rwlockattr_t = ::std::os::raw::c_long;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct pthread_spinlock_t {
    pub __private: i64,
}
#[test]
fn bindgen_test_layout_pthread_spinlock_t() {
    const UNINIT: ::std::mem::MaybeUninit<pthread_spinlock_t> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<pthread_spinlock_t>(),
        8usize,
        concat!("Size of: ", stringify!(pthread_spinlock_t))
    );
    assert_eq!(
        ::std::mem::align_of::<pthread_spinlock_t>(),
        8usize,
        concat!("Alignment of ", stringify!(pthread_spinlock_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__private) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_spinlock_t),
            "::",
            stringify!(__private)
        )
    );
}
pub type pthread_t = ::std::os::raw::c_long;
pub type __gid_t = __kernel_gid32_t;
pub type gid_t = __gid_t;
pub type __uid_t = __kernel_uid32_t;
pub type uid_t = __uid_t;
pub type __pid_t = __kernel_pid_t;
pub type pid_t = __pid_t;
pub type __id_t = u32;
pub type id_t = __id_t;
pub type blkcnt_t = ::std::os::raw::c_ulong;
pub type blksize_t = ::std::os::raw::c_ulong;
pub type caddr_t = __kernel_caddr_t;
pub type clock_t = __kernel_clock_t;
pub type __clockid_t = __kernel_clockid_t;
pub type clockid_t = __clockid_t;
pub type daddr_t = __kernel_daddr_t;
pub type fsblkcnt_t = ::std::os::raw::c_ulong;
pub type fsfilcnt_t = ::std::os::raw::c_ulong;
pub type __mode_t = __kernel_mode_t;
pub type mode_t = __mode_t;
pub type __key_t = __kernel_key_t;
pub type key_t = __key_t;
pub type __ino_t = __kernel_ino_t;
pub type ino_t = __ino_t;
pub type ino64_t = u64;
pub type __nlink_t = u32;
pub type nlink_t = __nlink_t;
pub type __timer_t = *mut ::std::os::raw::c_void;
pub type timer_t = __timer_t;
pub type __suseconds_t = __kernel_suseconds_t;
pub type suseconds_t = __suseconds_t;
pub type __useconds_t = u32;
pub type useconds_t = __useconds_t;
pub type dev_t = u64;
pub type __time_t = __kernel_time_t;
pub type time_t = __time_t;
pub type off_t = i64;
pub type loff_t = off_t;
pub type off64_t = loff_t;
pub type __socklen_t = u32;
pub type socklen_t = __socklen_t;
pub type __va_list = [u64; 4usize];
pub type uint_t = ::std::os::raw::c_uint;
pub type uint = ::std::os::raw::c_uint;
pub type u_char = ::std::os::raw::c_uchar;
pub type u_short = ::std::os::raw::c_ushort;
pub type u_int = ::std::os::raw::c_uint;
pub type u_long = ::std::os::raw::c_ulong;
pub type u_int32_t = u32;
pub type u_int16_t = u16;
pub type u_int8_t = u8;
pub type u_int64_t = u64;
pub type __gnuc_va_list = [u64; 4usize];
pub type va_list = [u64; 4usize];
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __locale_t {
    _unused: [u8; 0],
}
pub type locale_t = *mut __locale_t;
extern "C" {
    pub fn strcasecmp(
        __s1: *const ::std::os::raw::c_char,
        __s2: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn strcasecmp_l(
        __s1: *const ::std::os::raw::c_char,
        __s2: *const ::std::os::raw::c_char,
        __l: locale_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn strncasecmp(
        __s1: *const ::std::os::raw::c_char,
        __s2: *const ::std::os::raw::c_char,
        __n: ::std::os::raw::c_ulong,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn strncasecmp_l(
        __s1: *const ::std::os::raw::c_char,
        __s2: *const ::std::os::raw::c_char,
        __n: usize,
        __l: locale_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn memccpy(
        __dst: *mut ::std::os::raw::c_void,
        __src: *const ::std::os::raw::c_void,
        __stop_char: ::std::os::raw::c_int,
        __n: ::std::os::raw::c_ulong,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn memchr(
        __s: *const ::std::os::raw::c_void,
        __ch: ::std::os::raw::c_int,
        __n: ::std::os::raw::c_ulong,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn memrchr(
        __s: *const ::std::os::raw::c_void,
        __ch: ::std::os::raw::c_int,
        __n: usize,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn memcmp(
        __lhs: *const ::std::os::raw::c_void,
        __rhs: *const ::std::os::raw::c_void,
        __n: ::std::os::raw::c_ulong,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn memcpy(
        arg1: *mut ::std::os::raw::c_void,
        arg2: *const ::std::os::raw::c_void,
        arg3: ::std::os::raw::c_ulong,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn memmove(
        __dst: *mut ::std::os::raw::c_void,
        __src: *const ::std::os::raw::c_void,
        __n: ::std::os::raw::c_ulong,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn memset(
        __dst: *mut ::std::os::raw::c_void,
        __ch: ::std::os::raw::c_int,
        __n: ::std::os::raw::c_ulong,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn memmem(
        __haystack: *const ::std::os::raw::c_void,
        __haystack_size: usize,
        __needle: *const ::std::os::raw::c_void,
        __needle_size: usize,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn strchr(__s: *const ::std::os::raw::c_char, __ch: ::std::os::raw::c_int) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn __strchr_chk(
        __s: *const ::std::os::raw::c_char,
        __ch: ::std::os::raw::c_int,
        __n: usize,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn strrchr(__s: *const ::std::os::raw::c_char, __ch: ::std::os::raw::c_int) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn __strrchr_chk(
        __s: *const ::std::os::raw::c_char,
        __ch: ::std::os::raw::c_int,
        __n: usize,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn strlen(__s: *const ::std::os::raw::c_char) -> ::std::os::raw::c_ulong;
}
extern "C" {
    pub fn __strlen_chk(__s: *const ::std::os::raw::c_char, __n: usize) -> usize;
}
extern "C" {
    pub fn strcmp(__lhs: *const ::std::os::raw::c_char, __rhs: *const ::std::os::raw::c_char) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn stpcpy(
        __dst: *mut ::std::os::raw::c_char,
        __src: *const ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn strcpy(
        __dst: *mut ::std::os::raw::c_char,
        __src: *const ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn strcat(
        __dst: *mut ::std::os::raw::c_char,
        __src: *const ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn strdup(__s: *const ::std::os::raw::c_char) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn strstr(
        __haystack: *const ::std::os::raw::c_char,
        __needle: *const ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn strcasestr(
        __haystack: *const ::std::os::raw::c_char,
        __needle: *const ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn strtok(
        __s: *mut ::std::os::raw::c_char,
        __delimiter: *const ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn strtok_r(
        __s: *mut ::std::os::raw::c_char,
        __delimiter: *const ::std::os::raw::c_char,
        __pos_ptr: *mut *mut ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn strerror(__errno_value: ::std::os::raw::c_int) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn strerror_l(__errno_value: ::std::os::raw::c_int, __l: locale_t) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn strerror_r(
        __errno_value: ::std::os::raw::c_int,
        __buf: *mut ::std::os::raw::c_char,
        __n: usize,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn strnlen(__s: *const ::std::os::raw::c_char, __n: usize) -> usize;
}
extern "C" {
    pub fn strncat(
        __dst: *mut ::std::os::raw::c_char,
        __src: *const ::std::os::raw::c_char,
        __n: ::std::os::raw::c_ulong,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn strndup(__s: *const ::std::os::raw::c_char, __n: ::std::os::raw::c_ulong) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn strncmp(
        __lhs: *const ::std::os::raw::c_char,
        __rhs: *const ::std::os::raw::c_char,
        __n: ::std::os::raw::c_ulong,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn stpncpy(
        __dst: *mut ::std::os::raw::c_char,
        __src: *const ::std::os::raw::c_char,
        __n: ::std::os::raw::c_ulong,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn strncpy(
        __dst: *mut ::std::os::raw::c_char,
        __src: *const ::std::os::raw::c_char,
        __n: ::std::os::raw::c_ulong,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn strlcat(
        __dst: *mut ::std::os::raw::c_char,
        __src: *const ::std::os::raw::c_char,
        __n: ::std::os::raw::c_ulong,
    ) -> ::std::os::raw::c_ulong;
}
extern "C" {
    pub fn strlcpy(
        __dst: *mut ::std::os::raw::c_char,
        __src: *const ::std::os::raw::c_char,
        __n: ::std::os::raw::c_ulong,
    ) -> ::std::os::raw::c_ulong;
}
extern "C" {
    pub fn strcspn(
        __s: *const ::std::os::raw::c_char,
        __reject: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_ulong;
}
extern "C" {
    pub fn strpbrk(
        __s: *const ::std::os::raw::c_char,
        __accept: *const ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn strsep(
        __s_ptr: *mut *mut ::std::os::raw::c_char,
        __delimiter: *const ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn strspn(
        __s: *const ::std::os::raw::c_char,
        __accept: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_ulong;
}
extern "C" {
    pub fn strsignal(__signal: ::std::os::raw::c_int) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn strcoll(__lhs: *const ::std::os::raw::c_char, __rhs: *const ::std::os::raw::c_char)
        -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn strxfrm(
        __dst: *mut ::std::os::raw::c_char,
        __src: *const ::std::os::raw::c_char,
        __n: ::std::os::raw::c_ulong,
    ) -> ::std::os::raw::c_ulong;
}
extern "C" {
    pub fn strcoll_l(
        __lhs: *const ::std::os::raw::c_char,
        __rhs: *const ::std::os::raw::c_char,
        __l: locale_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn strxfrm_l(
        __dst: *mut ::std::os::raw::c_char,
        __src: *const ::std::os::raw::c_char,
        __n: usize,
        __l: locale_t,
    ) -> usize;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct flock {
    pub l_type: ::std::os::raw::c_short,
    pub l_whence: ::std::os::raw::c_short,
    pub l_start: off64_t,
    pub l_len: off64_t,
    pub l_pid: pid_t,
}
#[test]
fn bindgen_test_layout_flock() {
    const UNINIT: ::std::mem::MaybeUninit<flock> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<flock>(),
        32usize,
        concat!("Size of: ", stringify!(flock))
    );
    assert_eq!(
        ::std::mem::align_of::<flock>(),
        8usize,
        concat!("Alignment of ", stringify!(flock))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).l_type) as usize - ptr as usize },
        0usize,
        concat!("Offset of field: ", stringify!(flock), "::", stringify!(l_type))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).l_whence) as usize - ptr as usize },
        2usize,
        concat!("Offset of field: ", stringify!(flock), "::", stringify!(l_whence))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).l_start) as usize - ptr as usize },
        8usize,
        concat!("Offset of field: ", stringify!(flock), "::", stringify!(l_start))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).l_len) as usize - ptr as usize },
        16usize,
        concat!("Offset of field: ", stringify!(flock), "::", stringify!(l_len))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).l_pid) as usize - ptr as usize },
        24usize,
        concat!("Offset of field: ", stringify!(flock), "::", stringify!(l_pid))
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct flock64 {
    pub l_type: ::std::os::raw::c_short,
    pub l_whence: ::std::os::raw::c_short,
    pub l_start: off64_t,
    pub l_len: off64_t,
    pub l_pid: pid_t,
}
#[test]
fn bindgen_test_layout_flock64() {
    const UNINIT: ::std::mem::MaybeUninit<flock64> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<flock64>(),
        32usize,
        concat!("Size of: ", stringify!(flock64))
    );
    assert_eq!(
        ::std::mem::align_of::<flock64>(),
        8usize,
        concat!("Alignment of ", stringify!(flock64))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).l_type) as usize - ptr as usize },
        0usize,
        concat!("Offset of field: ", stringify!(flock64), "::", stringify!(l_type))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).l_whence) as usize - ptr as usize },
        2usize,
        concat!("Offset of field: ", stringify!(flock64), "::", stringify!(l_whence))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).l_start) as usize - ptr as usize },
        8usize,
        concat!("Offset of field: ", stringify!(flock64), "::", stringify!(l_start))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).l_len) as usize - ptr as usize },
        16usize,
        concat!("Offset of field: ", stringify!(flock64), "::", stringify!(l_len))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).l_pid) as usize - ptr as usize },
        24usize,
        concat!("Offset of field: ", stringify!(flock64), "::", stringify!(l_pid))
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct f_owner_ex {
    pub type_: ::std::os::raw::c_int,
    pub pid: __kernel_pid_t,
}
#[test]
fn bindgen_test_layout_f_owner_ex() {
    const UNINIT: ::std::mem::MaybeUninit<f_owner_ex> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<f_owner_ex>(),
        8usize,
        concat!("Size of: ", stringify!(f_owner_ex))
    );
    assert_eq!(
        ::std::mem::align_of::<f_owner_ex>(),
        4usize,
        concat!("Alignment of ", stringify!(f_owner_ex))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).type_) as usize - ptr as usize },
        0usize,
        concat!("Offset of field: ", stringify!(f_owner_ex), "::", stringify!(type_))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).pid) as usize - ptr as usize },
        4usize,
        concat!("Offset of field: ", stringify!(f_owner_ex), "::", stringify!(pid))
    );
}
pub type fpos_t = off_t;
pub type fpos64_t = off64_t;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __sFILE {
    _unused: [u8; 0],
}
pub type FILE = __sFILE;
extern "C" {
    pub static mut stdin: *mut FILE;
}
extern "C" {
    pub static mut stdout: *mut FILE;
}
extern "C" {
    pub static mut stderr: *mut FILE;
}
extern "C" {
    pub fn clearerr(__fp: *mut FILE);
}
extern "C" {
    pub fn fclose(__fp: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn feof(__fp: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ferror(__fp: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fflush(__fp: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fgetc(__fp: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fgets(
        __buf: *mut ::std::os::raw::c_char,
        __size: ::std::os::raw::c_int,
        __fp: *mut FILE,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn fprintf(__fp: *mut FILE, __fmt: *const ::std::os::raw::c_char, ...) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fputc(__ch: ::std::os::raw::c_int, __fp: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fputs(__s: *const ::std::os::raw::c_char, __fp: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fread(
        __buf: *mut ::std::os::raw::c_void,
        __size: ::std::os::raw::c_ulong,
        __count: ::std::os::raw::c_ulong,
        __fp: *mut FILE,
    ) -> ::std::os::raw::c_ulong;
}
extern "C" {
    pub fn fscanf(__fp: *mut FILE, __fmt: *const ::std::os::raw::c_char, ...) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fwrite(
        __buf: *const ::std::os::raw::c_void,
        __size: ::std::os::raw::c_ulong,
        __count: ::std::os::raw::c_ulong,
        __fp: *mut FILE,
    ) -> ::std::os::raw::c_ulong;
}
extern "C" {
    pub fn getc(__fp: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn getchar() -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn getdelim(
        __line_ptr: *mut *mut ::std::os::raw::c_char,
        __line_length_ptr: *mut usize,
        __delimiter: ::std::os::raw::c_int,
        __fp: *mut FILE,
    ) -> isize;
}
extern "C" {
    pub fn getline(
        __line_ptr: *mut *mut ::std::os::raw::c_char,
        __line_length_ptr: *mut usize,
        __fp: *mut FILE,
    ) -> isize;
}
extern "C" {
    pub fn perror(__msg: *const ::std::os::raw::c_char);
}
extern "C" {
    pub fn printf(__fmt: *const ::std::os::raw::c_char, ...) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn putc(__ch: ::std::os::raw::c_int, __fp: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn putchar(__ch: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn puts(__s: *const ::std::os::raw::c_char) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn remove(__path: *const ::std::os::raw::c_char) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn rewind(__fp: *mut FILE);
}
extern "C" {
    pub fn scanf(__fmt: *const ::std::os::raw::c_char, ...) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn setbuf(__fp: *mut FILE, __buf: *mut ::std::os::raw::c_char);
}
extern "C" {
    pub fn setvbuf(
        __fp: *mut FILE,
        __buf: *mut ::std::os::raw::c_char,
        __mode: ::std::os::raw::c_int,
        __size: usize,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn sscanf(
        __s: *const ::std::os::raw::c_char,
        __fmt: *const ::std::os::raw::c_char,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ungetc(__ch: ::std::os::raw::c_int, __fp: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn vfprintf(
        __fp: *mut FILE,
        __fmt: *const ::std::os::raw::c_char,
        __args: [u64; 4usize],
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn vprintf(__fp: *const ::std::os::raw::c_char, __args: [u64; 4usize]) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn dprintf(__fd: ::std::os::raw::c_int, __fmt: *const ::std::os::raw::c_char, ...) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn vdprintf(
        __fd: ::std::os::raw::c_int,
        __fmt: *const ::std::os::raw::c_char,
        __args: va_list,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn sprintf(
        __s: *mut ::std::os::raw::c_char,
        __fmt: *const ::std::os::raw::c_char,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn vsprintf(
        __s: *mut ::std::os::raw::c_char,
        __fmt: *const ::std::os::raw::c_char,
        __args: [u64; 4usize],
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn tmpnam(__s: *mut ::std::os::raw::c_char) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn tempnam(
        __dir: *const ::std::os::raw::c_char,
        __prefix: *const ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn rename(
        __old_path: *const ::std::os::raw::c_char,
        __new_path: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn renameat(
        __old_dir_fd: ::std::os::raw::c_int,
        __old_path: *const ::std::os::raw::c_char,
        __new_dir_fd: ::std::os::raw::c_int,
        __new_path: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fseek(
        __fp: *mut FILE,
        __offset: ::std::os::raw::c_long,
        __whence: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ftell(__fp: *mut FILE) -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn fgetpos(__fp: *mut FILE, __pos: *mut fpos_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fsetpos(__fp: *mut FILE, __pos: *const fpos_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fseeko(__fp: *mut FILE, __offset: off_t, __whence: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ftello(__fp: *mut FILE) -> off_t;
}
extern "C" {
    pub fn fgetpos64(__fp: *mut FILE, __pos: *mut fpos64_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fsetpos64(__fp: *mut FILE, __pos: *const fpos64_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fseeko64(__fp: *mut FILE, __offset: off64_t, __whence: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ftello64(__fp: *mut FILE) -> off64_t;
}
extern "C" {
    pub fn fopen(__path: *const ::std::os::raw::c_char, __mode: *const ::std::os::raw::c_char) -> *mut FILE;
}
extern "C" {
    pub fn fopen64(__path: *const ::std::os::raw::c_char, __mode: *const ::std::os::raw::c_char) -> *mut FILE;
}
extern "C" {
    pub fn freopen(
        __path: *const ::std::os::raw::c_char,
        __mode: *const ::std::os::raw::c_char,
        __fp: *mut FILE,
    ) -> *mut FILE;
}
extern "C" {
    pub fn freopen64(
        __path: *const ::std::os::raw::c_char,
        __mode: *const ::std::os::raw::c_char,
        __fp: *mut FILE,
    ) -> *mut FILE;
}
extern "C" {
    pub fn tmpfile64() -> *mut FILE;
}
extern "C" {
    pub fn snprintf(
        __buf: *mut ::std::os::raw::c_char,
        __size: ::std::os::raw::c_ulong,
        __fmt: *const ::std::os::raw::c_char,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn vfscanf(
        __fp: *mut FILE,
        __fmt: *const ::std::os::raw::c_char,
        __args: [u64; 4usize],
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn vscanf(__fmt: *const ::std::os::raw::c_char, __args: [u64; 4usize]) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn vsnprintf(
        __buf: *mut ::std::os::raw::c_char,
        __size: ::std::os::raw::c_ulong,
        __fmt: *const ::std::os::raw::c_char,
        __args: [u64; 4usize],
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn vsscanf(
        __s: *const ::std::os::raw::c_char,
        __fmt: *const ::std::os::raw::c_char,
        __args: [u64; 4usize],
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fdopen(__fd: ::std::os::raw::c_int, __mode: *const ::std::os::raw::c_char) -> *mut FILE;
}
extern "C" {
    pub fn fileno(__fp: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pclose(__fp: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn popen(__command: *const ::std::os::raw::c_char, __mode: *const ::std::os::raw::c_char) -> *mut FILE;
}
extern "C" {
    pub fn flockfile(__fp: *mut FILE);
}
extern "C" {
    pub fn ftrylockfile(__fp: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn funlockfile(__fp: *mut FILE);
}
extern "C" {
    pub fn getc_unlocked(__fp: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn getchar_unlocked() -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn putc_unlocked(__ch: ::std::os::raw::c_int, __fp: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn putchar_unlocked(__ch: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fmemopen(
        __buf: *mut ::std::os::raw::c_void,
        __size: usize,
        __mode: *const ::std::os::raw::c_char,
    ) -> *mut FILE;
}
extern "C" {
    pub fn open_memstream(__ptr: *mut *mut ::std::os::raw::c_char, __size_ptr: *mut usize) -> *mut FILE;
}
extern "C" {
    pub fn asprintf(
        __s_ptr: *mut *mut ::std::os::raw::c_char,
        __fmt: *const ::std::os::raw::c_char,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fgetln(__fp: *mut FILE, __length_ptr: *mut usize) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn fpurge(__fp: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn setbuffer(__fp: *mut FILE, __buf: *mut ::std::os::raw::c_char, __size: ::std::os::raw::c_int);
}
extern "C" {
    pub fn setlinebuf(__fp: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn vasprintf(
        __s_ptr: *mut *mut ::std::os::raw::c_char,
        __fmt: *const ::std::os::raw::c_char,
        __args: va_list,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn clearerr_unlocked(__fp: *mut FILE);
}
extern "C" {
    pub fn feof_unlocked(__fp: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ferror_unlocked(__fp: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fileno_unlocked(__fp: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn open(arg1: *const ::std::os::raw::c_char, arg2: ::std::os::raw::c_int, ...) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn getpid() -> pid_t;
}
extern "C" {
    pub fn unlink(arg1: *const ::std::os::raw::c_char) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn free(p: *mut ::std::os::raw::c_void);
}
extern "C" {
    pub fn arc4random() -> u32;
}
extern "C" {
    pub fn malloc(__byte_count: ::std::os::raw::c_ulong) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn calloc(
        __item_count: ::std::os::raw::c_ulong,
        __item_size: ::std::os::raw::c_ulong,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn realloc(
        __ptr: *mut ::std::os::raw::c_void,
        __byte_count: ::std::os::raw::c_ulong,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn memalign(
        __alignment: ::std::os::raw::c_ulong,
        __byte_count: ::std::os::raw::c_ulong,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn malloc_usable_size(__ptr: *const ::std::os::raw::c_void) -> usize;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct mallinfo {
    pub arena: usize,
    pub ordblks: usize,
    pub smblks: usize,
    pub hblks: usize,
    pub hblkhd: usize,
    pub usmblks: usize,
    pub fsmblks: usize,
    pub uordblks: usize,
    pub fordblks: usize,
    pub keepcost: usize,
}
#[test]
fn bindgen_test_layout_mallinfo() {
    const UNINIT: ::std::mem::MaybeUninit<mallinfo> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<mallinfo>(),
        80usize,
        concat!("Size of: ", stringify!(mallinfo))
    );
    assert_eq!(
        ::std::mem::align_of::<mallinfo>(),
        8usize,
        concat!("Alignment of ", stringify!(mallinfo))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).arena) as usize - ptr as usize },
        0usize,
        concat!("Offset of field: ", stringify!(mallinfo), "::", stringify!(arena))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ordblks) as usize - ptr as usize },
        8usize,
        concat!("Offset of field: ", stringify!(mallinfo), "::", stringify!(ordblks))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).smblks) as usize - ptr as usize },
        16usize,
        concat!("Offset of field: ", stringify!(mallinfo), "::", stringify!(smblks))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).hblks) as usize - ptr as usize },
        24usize,
        concat!("Offset of field: ", stringify!(mallinfo), "::", stringify!(hblks))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).hblkhd) as usize - ptr as usize },
        32usize,
        concat!("Offset of field: ", stringify!(mallinfo), "::", stringify!(hblkhd))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).usmblks) as usize - ptr as usize },
        40usize,
        concat!("Offset of field: ", stringify!(mallinfo), "::", stringify!(usmblks))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).fsmblks) as usize - ptr as usize },
        48usize,
        concat!("Offset of field: ", stringify!(mallinfo), "::", stringify!(fsmblks))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).uordblks) as usize - ptr as usize },
        56usize,
        concat!("Offset of field: ", stringify!(mallinfo), "::", stringify!(uordblks))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).fordblks) as usize - ptr as usize },
        64usize,
        concat!("Offset of field: ", stringify!(mallinfo), "::", stringify!(fordblks))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).keepcost) as usize - ptr as usize },
        72usize,
        concat!("Offset of field: ", stringify!(mallinfo), "::", stringify!(keepcost))
    );
}
extern "C" {
    pub fn mallinfo() -> mallinfo;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct mallinfo2 {
    pub arena: usize,
    pub ordblks: usize,
    pub smblks: usize,
    pub hblks: usize,
    pub hblkhd: usize,
    pub usmblks: usize,
    pub fsmblks: usize,
    pub uordblks: usize,
    pub fordblks: usize,
    pub keepcost: usize,
}
#[test]
fn bindgen_test_layout_mallinfo2() {
    const UNINIT: ::std::mem::MaybeUninit<mallinfo2> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<mallinfo2>(),
        80usize,
        concat!("Size of: ", stringify!(mallinfo2))
    );
    assert_eq!(
        ::std::mem::align_of::<mallinfo2>(),
        8usize,
        concat!("Alignment of ", stringify!(mallinfo2))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).arena) as usize - ptr as usize },
        0usize,
        concat!("Offset of field: ", stringify!(mallinfo2), "::", stringify!(arena))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ordblks) as usize - ptr as usize },
        8usize,
        concat!("Offset of field: ", stringify!(mallinfo2), "::", stringify!(ordblks))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).smblks) as usize - ptr as usize },
        16usize,
        concat!("Offset of field: ", stringify!(mallinfo2), "::", stringify!(smblks))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).hblks) as usize - ptr as usize },
        24usize,
        concat!("Offset of field: ", stringify!(mallinfo2), "::", stringify!(hblks))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).hblkhd) as usize - ptr as usize },
        32usize,
        concat!("Offset of field: ", stringify!(mallinfo2), "::", stringify!(hblkhd))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).usmblks) as usize - ptr as usize },
        40usize,
        concat!("Offset of field: ", stringify!(mallinfo2), "::", stringify!(usmblks))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).fsmblks) as usize - ptr as usize },
        48usize,
        concat!("Offset of field: ", stringify!(mallinfo2), "::", stringify!(fsmblks))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).uordblks) as usize - ptr as usize },
        56usize,
        concat!("Offset of field: ", stringify!(mallinfo2), "::", stringify!(uordblks))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).fordblks) as usize - ptr as usize },
        64usize,
        concat!("Offset of field: ", stringify!(mallinfo2), "::", stringify!(fordblks))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).keepcost) as usize - ptr as usize },
        72usize,
        concat!("Offset of field: ", stringify!(mallinfo2), "::", stringify!(keepcost))
    );
}
extern "C" {
    pub fn mallinfo2() -> mallinfo2;
}
extern "C" {
    pub fn malloc_info(__must_be_zero: ::std::os::raw::c_int, __fp: *mut FILE) -> ::std::os::raw::c_int;
}
pub const HeapTaggingLevel_M_HEAP_TAGGING_LEVEL_NONE: HeapTaggingLevel = 0;
pub const HeapTaggingLevel_M_HEAP_TAGGING_LEVEL_TBI: HeapTaggingLevel = 1;
pub const HeapTaggingLevel_M_HEAP_TAGGING_LEVEL_ASYNC: HeapTaggingLevel = 2;
pub const HeapTaggingLevel_M_HEAP_TAGGING_LEVEL_SYNC: HeapTaggingLevel = 3;
pub type HeapTaggingLevel = ::std::os::raw::c_uint;
extern "C" {
    pub fn abort() -> !;
}
extern "C" {
    pub fn exit(__status: ::std::os::raw::c_int) -> !;
}
extern "C" {
    pub fn _Exit(__status: ::std::os::raw::c_int) -> !;
}
extern "C" {
    pub fn atexit(__fn: ::std::option::Option<unsafe extern "C" fn()>) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn at_quick_exit(__fn: ::std::option::Option<unsafe extern "C" fn()>) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn quick_exit(__status: ::std::os::raw::c_int) -> !;
}
extern "C" {
    pub fn getenv(__name: *const ::std::os::raw::c_char) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn putenv(__assignment: *mut ::std::os::raw::c_char) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn setenv(
        __name: *const ::std::os::raw::c_char,
        __value: *const ::std::os::raw::c_char,
        __overwrite: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn unsetenv(__name: *const ::std::os::raw::c_char) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn clearenv() -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn mkdtemp(__template: *mut ::std::os::raw::c_char) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn mktemp(__template: *mut ::std::os::raw::c_char) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn mkostemp64(__template: *mut ::std::os::raw::c_char, __flags: ::std::os::raw::c_int)
        -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn mkostemp(__template: *mut ::std::os::raw::c_char, __flags: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn mkostemps64(
        __template: *mut ::std::os::raw::c_char,
        __suffix_length: ::std::os::raw::c_int,
        __flags: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn mkostemps(
        __template: *mut ::std::os::raw::c_char,
        __suffix_length: ::std::os::raw::c_int,
        __flags: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn mkstemp64(__template: *mut ::std::os::raw::c_char) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn mkstemp(__template: *mut ::std::os::raw::c_char) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn mkstemps64(__template: *mut ::std::os::raw::c_char, __flags: ::std::os::raw::c_int)
        -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn mkstemps(__template: *mut ::std::os::raw::c_char, __flags: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn strtol(
        __s: *const ::std::os::raw::c_char,
        __end_ptr: *mut *mut ::std::os::raw::c_char,
        __base: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn strtoll(
        __s: *const ::std::os::raw::c_char,
        __end_ptr: *mut *mut ::std::os::raw::c_char,
        __base: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_longlong;
}
extern "C" {
    pub fn strtoul(
        __s: *const ::std::os::raw::c_char,
        __end_ptr: *mut *mut ::std::os::raw::c_char,
        __base: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_ulong;
}
extern "C" {
    pub fn strtoull(
        __s: *const ::std::os::raw::c_char,
        __end_ptr: *mut *mut ::std::os::raw::c_char,
        __base: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_ulonglong;
}
extern "C" {
    pub fn posix_memalign(
        __memptr: *mut *mut ::std::os::raw::c_void,
        __alignment: usize,
        __size: usize,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn strtod(__s: *const ::std::os::raw::c_char, __end_ptr: *mut *mut ::std::os::raw::c_char) -> f64;
}
extern "C" {
    pub fn strtold(__s: *const ::std::os::raw::c_char, __end_ptr: *mut *mut ::std::os::raw::c_char) -> u128;
}
extern "C" {
    pub fn atol(__s: *const ::std::os::raw::c_char) -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn atoll(__s: *const ::std::os::raw::c_char) -> ::std::os::raw::c_longlong;
}
extern "C" {
    pub fn realpath(
        __path: *const ::std::os::raw::c_char,
        __resolved: *mut ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn system(__command: *const ::std::os::raw::c_char) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn bsearch(
        __key: *const ::std::os::raw::c_void,
        __base: *const ::std::os::raw::c_void,
        __nmemb: usize,
        __size: usize,
        __comparator: ::std::option::Option<
            unsafe extern "C" fn(
                __lhs: *const ::std::os::raw::c_void,
                __rhs: *const ::std::os::raw::c_void,
            ) -> ::std::os::raw::c_int,
        >,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn qsort(
        __base: *mut ::std::os::raw::c_void,
        __nmemb: usize,
        __size: usize,
        __comparator: ::std::option::Option<
            unsafe extern "C" fn(
                __lhs: *const ::std::os::raw::c_void,
                __rhs: *const ::std::os::raw::c_void,
            ) -> ::std::os::raw::c_int,
        >,
    );
}
extern "C" {
    pub fn arc4random_uniform(__upper_bound: u32) -> u32;
}
extern "C" {
    pub fn arc4random_buf(__buf: *mut ::std::os::raw::c_void, __n: usize);
}
extern "C" {
    pub fn rand_r(__seed_ptr: *mut ::std::os::raw::c_uint) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn drand48() -> f64;
}
extern "C" {
    pub fn erand48(__xsubi: *mut ::std::os::raw::c_ushort) -> f64;
}
extern "C" {
    pub fn jrand48(__xsubi: *mut ::std::os::raw::c_ushort) -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn lcong48(__param: *mut ::std::os::raw::c_ushort);
}
extern "C" {
    pub fn lrand48() -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn mrand48() -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn nrand48(__xsubi: *mut ::std::os::raw::c_ushort) -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn seed48(__seed16v: *mut ::std::os::raw::c_ushort) -> *mut ::std::os::raw::c_ushort;
}
extern "C" {
    pub fn srand48(__seed: ::std::os::raw::c_long);
}
extern "C" {
    pub fn initstate(
        __seed: ::std::os::raw::c_uint,
        __state: *mut ::std::os::raw::c_char,
        __n: usize,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn setstate(__state: *mut ::std::os::raw::c_char) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn getpt() -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn posix_openpt(__flags: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ptsname(__fd: ::std::os::raw::c_int) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn ptsname_r(
        __fd: ::std::os::raw::c_int,
        __buf: *mut ::std::os::raw::c_char,
        __n: usize,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn unlockpt(__fd: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct div_t {
    pub quot: ::std::os::raw::c_int,
    pub rem: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_div_t() {
    const UNINIT: ::std::mem::MaybeUninit<div_t> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<div_t>(),
        8usize,
        concat!("Size of: ", stringify!(div_t))
    );
    assert_eq!(
        ::std::mem::align_of::<div_t>(),
        4usize,
        concat!("Alignment of ", stringify!(div_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).quot) as usize - ptr as usize },
        0usize,
        concat!("Offset of field: ", stringify!(div_t), "::", stringify!(quot))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).rem) as usize - ptr as usize },
        4usize,
        concat!("Offset of field: ", stringify!(div_t), "::", stringify!(rem))
    );
}
extern "C" {
    pub fn div(__numerator: ::std::os::raw::c_int, __denominator: ::std::os::raw::c_int) -> div_t;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ldiv_t {
    pub quot: ::std::os::raw::c_long,
    pub rem: ::std::os::raw::c_long,
}
#[test]
fn bindgen_test_layout_ldiv_t() {
    const UNINIT: ::std::mem::MaybeUninit<ldiv_t> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<ldiv_t>(),
        16usize,
        concat!("Size of: ", stringify!(ldiv_t))
    );
    assert_eq!(
        ::std::mem::align_of::<ldiv_t>(),
        8usize,
        concat!("Alignment of ", stringify!(ldiv_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).quot) as usize - ptr as usize },
        0usize,
        concat!("Offset of field: ", stringify!(ldiv_t), "::", stringify!(quot))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).rem) as usize - ptr as usize },
        8usize,
        concat!("Offset of field: ", stringify!(ldiv_t), "::", stringify!(rem))
    );
}
extern "C" {
    pub fn ldiv(__numerator: ::std::os::raw::c_long, __denominator: ::std::os::raw::c_long) -> ldiv_t;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct lldiv_t {
    pub quot: ::std::os::raw::c_longlong,
    pub rem: ::std::os::raw::c_longlong,
}
#[test]
fn bindgen_test_layout_lldiv_t() {
    const UNINIT: ::std::mem::MaybeUninit<lldiv_t> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<lldiv_t>(),
        16usize,
        concat!("Size of: ", stringify!(lldiv_t))
    );
    assert_eq!(
        ::std::mem::align_of::<lldiv_t>(),
        8usize,
        concat!("Alignment of ", stringify!(lldiv_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).quot) as usize - ptr as usize },
        0usize,
        concat!("Offset of field: ", stringify!(lldiv_t), "::", stringify!(quot))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).rem) as usize - ptr as usize },
        8usize,
        concat!("Offset of field: ", stringify!(lldiv_t), "::", stringify!(rem))
    );
}
extern "C" {
    pub fn lldiv(__numerator: ::std::os::raw::c_longlong, __denominator: ::std::os::raw::c_longlong) -> lldiv_t;
}
extern "C" {
    pub fn getprogname() -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn setprogname(__name: *const ::std::os::raw::c_char);
}
extern "C" {
    pub fn mblen(__s: *const ::std::os::raw::c_char, __n: usize) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn mbstowcs(__dst: *mut wchar_t, __src: *const ::std::os::raw::c_char, __n: usize) -> usize;
}
extern "C" {
    pub fn mbtowc(__wc_ptr: *mut wchar_t, __s: *const ::std::os::raw::c_char, __n: usize) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn wctomb(__dst: *mut ::std::os::raw::c_char, __wc: wchar_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn wcstombs(__dst: *mut ::std::os::raw::c_char, __src: *const wchar_t, __n: usize) -> usize;
}
extern "C" {
    pub fn abs(__x: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn labs(__x: ::std::os::raw::c_long) -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn llabs(__x: ::std::os::raw::c_longlong) -> ::std::os::raw::c_longlong;
}
extern "C" {
    pub fn strtof(__s: *const ::std::os::raw::c_char, __end_ptr: *mut *mut ::std::os::raw::c_char) -> f32;
}
extern "C" {
    pub fn atof(__s: *const ::std::os::raw::c_char) -> f64;
}
extern "C" {
    pub fn rand() -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn srand(__seed: ::std::os::raw::c_uint);
}
extern "C" {
    pub fn random() -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn srandom(__seed: ::std::os::raw::c_uint);
}
extern "C" {
    pub fn grantpt(__fd: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn strtoll_l(
        __s: *const ::std::os::raw::c_char,
        __end_ptr: *mut *mut ::std::os::raw::c_char,
        __base: ::std::os::raw::c_int,
        __l: locale_t,
    ) -> ::std::os::raw::c_longlong;
}
extern "C" {
    pub fn strtoull_l(
        __s: *const ::std::os::raw::c_char,
        __end_ptr: *mut *mut ::std::os::raw::c_char,
        __base: ::std::os::raw::c_int,
        __l: locale_t,
    ) -> ::std::os::raw::c_ulonglong;
}
extern "C" {
    pub fn strtold_l(
        __s: *const ::std::os::raw::c_char,
        __end_ptr: *mut *mut ::std::os::raw::c_char,
        __l: locale_t,
    ) -> u128;
}
pub type idx_t = u64;
pub const DUCKDB_TYPE_DUCKDB_TYPE_INVALID: DUCKDB_TYPE = 0;
pub const DUCKDB_TYPE_DUCKDB_TYPE_BOOLEAN: DUCKDB_TYPE = 1;
pub const DUCKDB_TYPE_DUCKDB_TYPE_TINYINT: DUCKDB_TYPE = 2;
pub const DUCKDB_TYPE_DUCKDB_TYPE_SMALLINT: DUCKDB_TYPE = 3;
pub const DUCKDB_TYPE_DUCKDB_TYPE_INTEGER: DUCKDB_TYPE = 4;
pub const DUCKDB_TYPE_DUCKDB_TYPE_BIGINT: DUCKDB_TYPE = 5;
pub const DUCKDB_TYPE_DUCKDB_TYPE_UTINYINT: DUCKDB_TYPE = 6;
pub const DUCKDB_TYPE_DUCKDB_TYPE_USMALLINT: DUCKDB_TYPE = 7;
pub const DUCKDB_TYPE_DUCKDB_TYPE_UINTEGER: DUCKDB_TYPE = 8;
pub const DUCKDB_TYPE_DUCKDB_TYPE_UBIGINT: DUCKDB_TYPE = 9;
pub const DUCKDB_TYPE_DUCKDB_TYPE_FLOAT: DUCKDB_TYPE = 10;
pub const DUCKDB_TYPE_DUCKDB_TYPE_DOUBLE: DUCKDB_TYPE = 11;
pub const DUCKDB_TYPE_DUCKDB_TYPE_TIMESTAMP: DUCKDB_TYPE = 12;
pub const DUCKDB_TYPE_DUCKDB_TYPE_DATE: DUCKDB_TYPE = 13;
pub const DUCKDB_TYPE_DUCKDB_TYPE_TIME: DUCKDB_TYPE = 14;
pub const DUCKDB_TYPE_DUCKDB_TYPE_INTERVAL: DUCKDB_TYPE = 15;
pub const DUCKDB_TYPE_DUCKDB_TYPE_HUGEINT: DUCKDB_TYPE = 16;
pub const DUCKDB_TYPE_DUCKDB_TYPE_VARCHAR: DUCKDB_TYPE = 17;
pub const DUCKDB_TYPE_DUCKDB_TYPE_BLOB: DUCKDB_TYPE = 18;
pub const DUCKDB_TYPE_DUCKDB_TYPE_DECIMAL: DUCKDB_TYPE = 19;
pub const DUCKDB_TYPE_DUCKDB_TYPE_TIMESTAMP_S: DUCKDB_TYPE = 20;
pub const DUCKDB_TYPE_DUCKDB_TYPE_TIMESTAMP_MS: DUCKDB_TYPE = 21;
pub const DUCKDB_TYPE_DUCKDB_TYPE_TIMESTAMP_NS: DUCKDB_TYPE = 22;
pub const DUCKDB_TYPE_DUCKDB_TYPE_ENUM: DUCKDB_TYPE = 23;
pub const DUCKDB_TYPE_DUCKDB_TYPE_LIST: DUCKDB_TYPE = 24;
pub const DUCKDB_TYPE_DUCKDB_TYPE_STRUCT: DUCKDB_TYPE = 25;
pub const DUCKDB_TYPE_DUCKDB_TYPE_MAP: DUCKDB_TYPE = 26;
pub const DUCKDB_TYPE_DUCKDB_TYPE_UUID: DUCKDB_TYPE = 27;
pub const DUCKDB_TYPE_DUCKDB_TYPE_UNION: DUCKDB_TYPE = 28;
pub const DUCKDB_TYPE_DUCKDB_TYPE_BIT: DUCKDB_TYPE = 29;
pub type DUCKDB_TYPE = ::std::os::raw::c_uint;
pub use self::DUCKDB_TYPE as duckdb_type;
#[doc = "! Days are stored as days since 1970-01-01\n! Use the duckdb_from_date/duckdb_to_date function to extract individual information"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct duckdb_date {
    pub days: i32,
}
#[test]
fn bindgen_test_layout_duckdb_date() {
    const UNINIT: ::std::mem::MaybeUninit<duckdb_date> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<duckdb_date>(),
        4usize,
        concat!("Size of: ", stringify!(duckdb_date))
    );
    assert_eq!(
        ::std::mem::align_of::<duckdb_date>(),
        4usize,
        concat!("Alignment of ", stringify!(duckdb_date))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).days) as usize - ptr as usize },
        0usize,
        concat!("Offset of field: ", stringify!(duckdb_date), "::", stringify!(days))
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct duckdb_date_struct {
    pub year: i32,
    pub month: i8,
    pub day: i8,
}
#[test]
fn bindgen_test_layout_duckdb_date_struct() {
    const UNINIT: ::std::mem::MaybeUninit<duckdb_date_struct> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<duckdb_date_struct>(),
        8usize,
        concat!("Size of: ", stringify!(duckdb_date_struct))
    );
    assert_eq!(
        ::std::mem::align_of::<duckdb_date_struct>(),
        4usize,
        concat!("Alignment of ", stringify!(duckdb_date_struct))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).year) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(duckdb_date_struct),
            "::",
            stringify!(year)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).month) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(duckdb_date_struct),
            "::",
            stringify!(month)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).day) as usize - ptr as usize },
        5usize,
        concat!(
            "Offset of field: ",
            stringify!(duckdb_date_struct),
            "::",
            stringify!(day)
        )
    );
}
#[doc = "! Time is stored as microseconds since 00:00:00\n! Use the duckdb_from_time/duckdb_to_time function to extract individual information"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct duckdb_time {
    pub micros: i64,
}
#[test]
fn bindgen_test_layout_duckdb_time() {
    const UNINIT: ::std::mem::MaybeUninit<duckdb_time> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<duckdb_time>(),
        8usize,
        concat!("Size of: ", stringify!(duckdb_time))
    );
    assert_eq!(
        ::std::mem::align_of::<duckdb_time>(),
        8usize,
        concat!("Alignment of ", stringify!(duckdb_time))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).micros) as usize - ptr as usize },
        0usize,
        concat!("Offset of field: ", stringify!(duckdb_time), "::", stringify!(micros))
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct duckdb_time_struct {
    pub hour: i8,
    pub min: i8,
    pub sec: i8,
    pub micros: i32,
}
#[test]
fn bindgen_test_layout_duckdb_time_struct() {
    const UNINIT: ::std::mem::MaybeUninit<duckdb_time_struct> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<duckdb_time_struct>(),
        8usize,
        concat!("Size of: ", stringify!(duckdb_time_struct))
    );
    assert_eq!(
        ::std::mem::align_of::<duckdb_time_struct>(),
        4usize,
        concat!("Alignment of ", stringify!(duckdb_time_struct))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).hour) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(duckdb_time_struct),
            "::",
            stringify!(hour)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).min) as usize - ptr as usize },
        1usize,
        concat!(
            "Offset of field: ",
            stringify!(duckdb_time_struct),
            "::",
            stringify!(min)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).sec) as usize - ptr as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(duckdb_time_struct),
            "::",
            stringify!(sec)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).micros) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(duckdb_time_struct),
            "::",
            stringify!(micros)
        )
    );
}
#[doc = "! Timestamps are stored as microseconds since 1970-01-01\n! Use the duckdb_from_timestamp/duckdb_to_timestamp function to extract individual information"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct duckdb_timestamp {
    pub micros: i64,
}
#[test]
fn bindgen_test_layout_duckdb_timestamp() {
    const UNINIT: ::std::mem::MaybeUninit<duckdb_timestamp> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<duckdb_timestamp>(),
        8usize,
        concat!("Size of: ", stringify!(duckdb_timestamp))
    );
    assert_eq!(
        ::std::mem::align_of::<duckdb_timestamp>(),
        8usize,
        concat!("Alignment of ", stringify!(duckdb_timestamp))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).micros) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(duckdb_timestamp),
            "::",
            stringify!(micros)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct duckdb_timestamp_struct {
    pub date: duckdb_date_struct,
    pub time: duckdb_time_struct,
}
#[test]
fn bindgen_test_layout_duckdb_timestamp_struct() {
    const UNINIT: ::std::mem::MaybeUninit<duckdb_timestamp_struct> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<duckdb_timestamp_struct>(),
        16usize,
        concat!("Size of: ", stringify!(duckdb_timestamp_struct))
    );
    assert_eq!(
        ::std::mem::align_of::<duckdb_timestamp_struct>(),
        4usize,
        concat!("Alignment of ", stringify!(duckdb_timestamp_struct))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).date) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(duckdb_timestamp_struct),
            "::",
            stringify!(date)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).time) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(duckdb_timestamp_struct),
            "::",
            stringify!(time)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct duckdb_interval {
    pub months: i32,
    pub days: i32,
    pub micros: i64,
}
#[test]
fn bindgen_test_layout_duckdb_interval() {
    const UNINIT: ::std::mem::MaybeUninit<duckdb_interval> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<duckdb_interval>(),
        16usize,
        concat!("Size of: ", stringify!(duckdb_interval))
    );
    assert_eq!(
        ::std::mem::align_of::<duckdb_interval>(),
        8usize,
        concat!("Alignment of ", stringify!(duckdb_interval))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).months) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(duckdb_interval),
            "::",
            stringify!(months)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).days) as usize - ptr as usize },
        4usize,
        concat!("Offset of field: ", stringify!(duckdb_interval), "::", stringify!(days))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).micros) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(duckdb_interval),
            "::",
            stringify!(micros)
        )
    );
}
#[doc = "! Hugeints are composed in a (lower, upper) component\n! The value of the hugeint is upper * 2^64 + lower\n! For easy usage, the functions duckdb_hugeint_to_double/duckdb_double_to_hugeint are recommended"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct duckdb_hugeint {
    pub lower: u64,
    pub upper: i64,
}
#[test]
fn bindgen_test_layout_duckdb_hugeint() {
    const UNINIT: ::std::mem::MaybeUninit<duckdb_hugeint> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<duckdb_hugeint>(),
        16usize,
        concat!("Size of: ", stringify!(duckdb_hugeint))
    );
    assert_eq!(
        ::std::mem::align_of::<duckdb_hugeint>(),
        8usize,
        concat!("Alignment of ", stringify!(duckdb_hugeint))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).lower) as usize - ptr as usize },
        0usize,
        concat!("Offset of field: ", stringify!(duckdb_hugeint), "::", stringify!(lower))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).upper) as usize - ptr as usize },
        8usize,
        concat!("Offset of field: ", stringify!(duckdb_hugeint), "::", stringify!(upper))
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct duckdb_decimal {
    pub width: u8,
    pub scale: u8,
    pub value: duckdb_hugeint,
}
#[test]
fn bindgen_test_layout_duckdb_decimal() {
    const UNINIT: ::std::mem::MaybeUninit<duckdb_decimal> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<duckdb_decimal>(),
        24usize,
        concat!("Size of: ", stringify!(duckdb_decimal))
    );
    assert_eq!(
        ::std::mem::align_of::<duckdb_decimal>(),
        8usize,
        concat!("Alignment of ", stringify!(duckdb_decimal))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).width) as usize - ptr as usize },
        0usize,
        concat!("Offset of field: ", stringify!(duckdb_decimal), "::", stringify!(width))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).scale) as usize - ptr as usize },
        1usize,
        concat!("Offset of field: ", stringify!(duckdb_decimal), "::", stringify!(scale))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).value) as usize - ptr as usize },
        8usize,
        concat!("Offset of field: ", stringify!(duckdb_decimal), "::", stringify!(value))
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct duckdb_string {
    pub data: *mut ::std::os::raw::c_char,
    pub size: idx_t,
}
#[test]
fn bindgen_test_layout_duckdb_string() {
    const UNINIT: ::std::mem::MaybeUninit<duckdb_string> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<duckdb_string>(),
        16usize,
        concat!("Size of: ", stringify!(duckdb_string))
    );
    assert_eq!(
        ::std::mem::align_of::<duckdb_string>(),
        8usize,
        concat!("Alignment of ", stringify!(duckdb_string))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).data) as usize - ptr as usize },
        0usize,
        concat!("Offset of field: ", stringify!(duckdb_string), "::", stringify!(data))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).size) as usize - ptr as usize },
        8usize,
        concat!("Offset of field: ", stringify!(duckdb_string), "::", stringify!(size))
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct duckdb_string_t {
    pub value: duckdb_string_t__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union duckdb_string_t__bindgen_ty_1 {
    pub pointer: duckdb_string_t__bindgen_ty_1__bindgen_ty_1,
    pub inlined: duckdb_string_t__bindgen_ty_1__bindgen_ty_2,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct duckdb_string_t__bindgen_ty_1__bindgen_ty_1 {
    pub length: u32,
    pub prefix: [::std::os::raw::c_char; 4usize],
    pub ptr: *mut ::std::os::raw::c_char,
}
#[test]
fn bindgen_test_layout_duckdb_string_t__bindgen_ty_1__bindgen_ty_1() {
    const UNINIT: ::std::mem::MaybeUninit<duckdb_string_t__bindgen_ty_1__bindgen_ty_1> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<duckdb_string_t__bindgen_ty_1__bindgen_ty_1>(),
        16usize,
        concat!("Size of: ", stringify!(duckdb_string_t__bindgen_ty_1__bindgen_ty_1))
    );
    assert_eq!(
        ::std::mem::align_of::<duckdb_string_t__bindgen_ty_1__bindgen_ty_1>(),
        8usize,
        concat!("Alignment of ", stringify!(duckdb_string_t__bindgen_ty_1__bindgen_ty_1))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).length) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(duckdb_string_t__bindgen_ty_1__bindgen_ty_1),
            "::",
            stringify!(length)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).prefix) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(duckdb_string_t__bindgen_ty_1__bindgen_ty_1),
            "::",
            stringify!(prefix)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ptr) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(duckdb_string_t__bindgen_ty_1__bindgen_ty_1),
            "::",
            stringify!(ptr)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct duckdb_string_t__bindgen_ty_1__bindgen_ty_2 {
    pub length: u32,
    pub inlined: [::std::os::raw::c_char; 12usize],
}
#[test]
fn bindgen_test_layout_duckdb_string_t__bindgen_ty_1__bindgen_ty_2() {
    const UNINIT: ::std::mem::MaybeUninit<duckdb_string_t__bindgen_ty_1__bindgen_ty_2> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<duckdb_string_t__bindgen_ty_1__bindgen_ty_2>(),
        16usize,
        concat!("Size of: ", stringify!(duckdb_string_t__bindgen_ty_1__bindgen_ty_2))
    );
    assert_eq!(
        ::std::mem::align_of::<duckdb_string_t__bindgen_ty_1__bindgen_ty_2>(),
        4usize,
        concat!("Alignment of ", stringify!(duckdb_string_t__bindgen_ty_1__bindgen_ty_2))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).length) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(duckdb_string_t__bindgen_ty_1__bindgen_ty_2),
            "::",
            stringify!(length)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).inlined) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(duckdb_string_t__bindgen_ty_1__bindgen_ty_2),
            "::",
            stringify!(inlined)
        )
    );
}
#[test]
fn bindgen_test_layout_duckdb_string_t__bindgen_ty_1() {
    const UNINIT: ::std::mem::MaybeUninit<duckdb_string_t__bindgen_ty_1> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<duckdb_string_t__bindgen_ty_1>(),
        16usize,
        concat!("Size of: ", stringify!(duckdb_string_t__bindgen_ty_1))
    );
    assert_eq!(
        ::std::mem::align_of::<duckdb_string_t__bindgen_ty_1>(),
        8usize,
        concat!("Alignment of ", stringify!(duckdb_string_t__bindgen_ty_1))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).pointer) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(duckdb_string_t__bindgen_ty_1),
            "::",
            stringify!(pointer)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).inlined) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(duckdb_string_t__bindgen_ty_1),
            "::",
            stringify!(inlined)
        )
    );
}
#[test]
fn bindgen_test_layout_duckdb_string_t() {
    const UNINIT: ::std::mem::MaybeUninit<duckdb_string_t> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<duckdb_string_t>(),
        16usize,
        concat!("Size of: ", stringify!(duckdb_string_t))
    );
    assert_eq!(
        ::std::mem::align_of::<duckdb_string_t>(),
        8usize,
        concat!("Alignment of ", stringify!(duckdb_string_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).value) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(duckdb_string_t),
            "::",
            stringify!(value)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct duckdb_blob {
    pub data: *mut ::std::os::raw::c_void,
    pub size: idx_t,
}
#[test]
fn bindgen_test_layout_duckdb_blob() {
    const UNINIT: ::std::mem::MaybeUninit<duckdb_blob> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<duckdb_blob>(),
        16usize,
        concat!("Size of: ", stringify!(duckdb_blob))
    );
    assert_eq!(
        ::std::mem::align_of::<duckdb_blob>(),
        8usize,
        concat!("Alignment of ", stringify!(duckdb_blob))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).data) as usize - ptr as usize },
        0usize,
        concat!("Offset of field: ", stringify!(duckdb_blob), "::", stringify!(data))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).size) as usize - ptr as usize },
        8usize,
        concat!("Offset of field: ", stringify!(duckdb_blob), "::", stringify!(size))
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct duckdb_list_entry {
    pub offset: u64,
    pub length: u64,
}
#[test]
fn bindgen_test_layout_duckdb_list_entry() {
    const UNINIT: ::std::mem::MaybeUninit<duckdb_list_entry> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<duckdb_list_entry>(),
        16usize,
        concat!("Size of: ", stringify!(duckdb_list_entry))
    );
    assert_eq!(
        ::std::mem::align_of::<duckdb_list_entry>(),
        8usize,
        concat!("Alignment of ", stringify!(duckdb_list_entry))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).offset) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(duckdb_list_entry),
            "::",
            stringify!(offset)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).length) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(duckdb_list_entry),
            "::",
            stringify!(length)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct duckdb_column {
    pub __deprecated_data: *mut ::std::os::raw::c_void,
    pub __deprecated_nullmask: *mut bool,
    pub __deprecated_type: duckdb_type,
    pub __deprecated_name: *mut ::std::os::raw::c_char,
    pub internal_data: *mut ::std::os::raw::c_void,
}
#[test]
fn bindgen_test_layout_duckdb_column() {
    const UNINIT: ::std::mem::MaybeUninit<duckdb_column> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<duckdb_column>(),
        40usize,
        concat!("Size of: ", stringify!(duckdb_column))
    );
    assert_eq!(
        ::std::mem::align_of::<duckdb_column>(),
        8usize,
        concat!("Alignment of ", stringify!(duckdb_column))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__deprecated_data) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(duckdb_column),
            "::",
            stringify!(__deprecated_data)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__deprecated_nullmask) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(duckdb_column),
            "::",
            stringify!(__deprecated_nullmask)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__deprecated_type) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(duckdb_column),
            "::",
            stringify!(__deprecated_type)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__deprecated_name) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(duckdb_column),
            "::",
            stringify!(__deprecated_name)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).internal_data) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(duckdb_column),
            "::",
            stringify!(internal_data)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct duckdb_result {
    pub __deprecated_column_count: idx_t,
    pub __deprecated_row_count: idx_t,
    pub __deprecated_rows_changed: idx_t,
    pub __deprecated_columns: *mut duckdb_column,
    pub __deprecated_error_message: *mut ::std::os::raw::c_char,
    pub internal_data: *mut ::std::os::raw::c_void,
}
#[test]
fn bindgen_test_layout_duckdb_result() {
    const UNINIT: ::std::mem::MaybeUninit<duckdb_result> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<duckdb_result>(),
        48usize,
        concat!("Size of: ", stringify!(duckdb_result))
    );
    assert_eq!(
        ::std::mem::align_of::<duckdb_result>(),
        8usize,
        concat!("Alignment of ", stringify!(duckdb_result))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__deprecated_column_count) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(duckdb_result),
            "::",
            stringify!(__deprecated_column_count)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__deprecated_row_count) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(duckdb_result),
            "::",
            stringify!(__deprecated_row_count)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__deprecated_rows_changed) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(duckdb_result),
            "::",
            stringify!(__deprecated_rows_changed)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__deprecated_columns) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(duckdb_result),
            "::",
            stringify!(__deprecated_columns)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__deprecated_error_message) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(duckdb_result),
            "::",
            stringify!(__deprecated_error_message)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).internal_data) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(duckdb_result),
            "::",
            stringify!(internal_data)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _duckdb_database {
    pub __db: *mut ::std::os::raw::c_void,
}
#[test]
fn bindgen_test_layout__duckdb_database() {
    const UNINIT: ::std::mem::MaybeUninit<_duckdb_database> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_duckdb_database>(),
        8usize,
        concat!("Size of: ", stringify!(_duckdb_database))
    );
    assert_eq!(
        ::std::mem::align_of::<_duckdb_database>(),
        8usize,
        concat!("Alignment of ", stringify!(_duckdb_database))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__db) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_duckdb_database),
            "::",
            stringify!(__db)
        )
    );
}
pub type duckdb_database = *mut _duckdb_database;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _duckdb_connection {
    pub __conn: *mut ::std::os::raw::c_void,
}
#[test]
fn bindgen_test_layout__duckdb_connection() {
    const UNINIT: ::std::mem::MaybeUninit<_duckdb_connection> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_duckdb_connection>(),
        8usize,
        concat!("Size of: ", stringify!(_duckdb_connection))
    );
    assert_eq!(
        ::std::mem::align_of::<_duckdb_connection>(),
        8usize,
        concat!("Alignment of ", stringify!(_duckdb_connection))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__conn) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_duckdb_connection),
            "::",
            stringify!(__conn)
        )
    );
}
pub type duckdb_connection = *mut _duckdb_connection;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _duckdb_prepared_statement {
    pub __prep: *mut ::std::os::raw::c_void,
}
#[test]
fn bindgen_test_layout__duckdb_prepared_statement() {
    const UNINIT: ::std::mem::MaybeUninit<_duckdb_prepared_statement> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_duckdb_prepared_statement>(),
        8usize,
        concat!("Size of: ", stringify!(_duckdb_prepared_statement))
    );
    assert_eq!(
        ::std::mem::align_of::<_duckdb_prepared_statement>(),
        8usize,
        concat!("Alignment of ", stringify!(_duckdb_prepared_statement))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__prep) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_duckdb_prepared_statement),
            "::",
            stringify!(__prep)
        )
    );
}
pub type duckdb_prepared_statement = *mut _duckdb_prepared_statement;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _duckdb_extracted_statements {
    pub __extrac: *mut ::std::os::raw::c_void,
}
#[test]
fn bindgen_test_layout__duckdb_extracted_statements() {
    const UNINIT: ::std::mem::MaybeUninit<_duckdb_extracted_statements> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_duckdb_extracted_statements>(),
        8usize,
        concat!("Size of: ", stringify!(_duckdb_extracted_statements))
    );
    assert_eq!(
        ::std::mem::align_of::<_duckdb_extracted_statements>(),
        8usize,
        concat!("Alignment of ", stringify!(_duckdb_extracted_statements))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__extrac) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_duckdb_extracted_statements),
            "::",
            stringify!(__extrac)
        )
    );
}
pub type duckdb_extracted_statements = *mut _duckdb_extracted_statements;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _duckdb_pending_result {
    pub __pend: *mut ::std::os::raw::c_void,
}
#[test]
fn bindgen_test_layout__duckdb_pending_result() {
    const UNINIT: ::std::mem::MaybeUninit<_duckdb_pending_result> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_duckdb_pending_result>(),
        8usize,
        concat!("Size of: ", stringify!(_duckdb_pending_result))
    );
    assert_eq!(
        ::std::mem::align_of::<_duckdb_pending_result>(),
        8usize,
        concat!("Alignment of ", stringify!(_duckdb_pending_result))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__pend) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_duckdb_pending_result),
            "::",
            stringify!(__pend)
        )
    );
}
pub type duckdb_pending_result = *mut _duckdb_pending_result;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _duckdb_appender {
    pub __appn: *mut ::std::os::raw::c_void,
}
#[test]
fn bindgen_test_layout__duckdb_appender() {
    const UNINIT: ::std::mem::MaybeUninit<_duckdb_appender> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_duckdb_appender>(),
        8usize,
        concat!("Size of: ", stringify!(_duckdb_appender))
    );
    assert_eq!(
        ::std::mem::align_of::<_duckdb_appender>(),
        8usize,
        concat!("Alignment of ", stringify!(_duckdb_appender))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__appn) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_duckdb_appender),
            "::",
            stringify!(__appn)
        )
    );
}
pub type duckdb_appender = *mut _duckdb_appender;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _duckdb_arrow {
    pub __arrw: *mut ::std::os::raw::c_void,
}
#[test]
fn bindgen_test_layout__duckdb_arrow() {
    const UNINIT: ::std::mem::MaybeUninit<_duckdb_arrow> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_duckdb_arrow>(),
        8usize,
        concat!("Size of: ", stringify!(_duckdb_arrow))
    );
    assert_eq!(
        ::std::mem::align_of::<_duckdb_arrow>(),
        8usize,
        concat!("Alignment of ", stringify!(_duckdb_arrow))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__arrw) as usize - ptr as usize },
        0usize,
        concat!("Offset of field: ", stringify!(_duckdb_arrow), "::", stringify!(__arrw))
    );
}
pub type duckdb_arrow = *mut _duckdb_arrow;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _duckdb_config {
    pub __cnfg: *mut ::std::os::raw::c_void,
}
#[test]
fn bindgen_test_layout__duckdb_config() {
    const UNINIT: ::std::mem::MaybeUninit<_duckdb_config> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_duckdb_config>(),
        8usize,
        concat!("Size of: ", stringify!(_duckdb_config))
    );
    assert_eq!(
        ::std::mem::align_of::<_duckdb_config>(),
        8usize,
        concat!("Alignment of ", stringify!(_duckdb_config))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__cnfg) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_duckdb_config),
            "::",
            stringify!(__cnfg)
        )
    );
}
pub type duckdb_config = *mut _duckdb_config;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _duckdb_arrow_schema {
    pub __arrs: *mut ::std::os::raw::c_void,
}
#[test]
fn bindgen_test_layout__duckdb_arrow_schema() {
    const UNINIT: ::std::mem::MaybeUninit<_duckdb_arrow_schema> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_duckdb_arrow_schema>(),
        8usize,
        concat!("Size of: ", stringify!(_duckdb_arrow_schema))
    );
    assert_eq!(
        ::std::mem::align_of::<_duckdb_arrow_schema>(),
        8usize,
        concat!("Alignment of ", stringify!(_duckdb_arrow_schema))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__arrs) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_duckdb_arrow_schema),
            "::",
            stringify!(__arrs)
        )
    );
}
pub type duckdb_arrow_schema = *mut _duckdb_arrow_schema;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _duckdb_arrow_array {
    pub __arra: *mut ::std::os::raw::c_void,
}
#[test]
fn bindgen_test_layout__duckdb_arrow_array() {
    const UNINIT: ::std::mem::MaybeUninit<_duckdb_arrow_array> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_duckdb_arrow_array>(),
        8usize,
        concat!("Size of: ", stringify!(_duckdb_arrow_array))
    );
    assert_eq!(
        ::std::mem::align_of::<_duckdb_arrow_array>(),
        8usize,
        concat!("Alignment of ", stringify!(_duckdb_arrow_array))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__arra) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_duckdb_arrow_array),
            "::",
            stringify!(__arra)
        )
    );
}
pub type duckdb_arrow_array = *mut _duckdb_arrow_array;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _duckdb_logical_type {
    pub __lglt: *mut ::std::os::raw::c_void,
}
#[test]
fn bindgen_test_layout__duckdb_logical_type() {
    const UNINIT: ::std::mem::MaybeUninit<_duckdb_logical_type> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_duckdb_logical_type>(),
        8usize,
        concat!("Size of: ", stringify!(_duckdb_logical_type))
    );
    assert_eq!(
        ::std::mem::align_of::<_duckdb_logical_type>(),
        8usize,
        concat!("Alignment of ", stringify!(_duckdb_logical_type))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__lglt) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_duckdb_logical_type),
            "::",
            stringify!(__lglt)
        )
    );
}
pub type duckdb_logical_type = *mut _duckdb_logical_type;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _duckdb_data_chunk {
    pub __dtck: *mut ::std::os::raw::c_void,
}
#[test]
fn bindgen_test_layout__duckdb_data_chunk() {
    const UNINIT: ::std::mem::MaybeUninit<_duckdb_data_chunk> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_duckdb_data_chunk>(),
        8usize,
        concat!("Size of: ", stringify!(_duckdb_data_chunk))
    );
    assert_eq!(
        ::std::mem::align_of::<_duckdb_data_chunk>(),
        8usize,
        concat!("Alignment of ", stringify!(_duckdb_data_chunk))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__dtck) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_duckdb_data_chunk),
            "::",
            stringify!(__dtck)
        )
    );
}
pub type duckdb_data_chunk = *mut _duckdb_data_chunk;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _duckdb_vector {
    pub __vctr: *mut ::std::os::raw::c_void,
}
#[test]
fn bindgen_test_layout__duckdb_vector() {
    const UNINIT: ::std::mem::MaybeUninit<_duckdb_vector> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_duckdb_vector>(),
        8usize,
        concat!("Size of: ", stringify!(_duckdb_vector))
    );
    assert_eq!(
        ::std::mem::align_of::<_duckdb_vector>(),
        8usize,
        concat!("Alignment of ", stringify!(_duckdb_vector))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__vctr) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_duckdb_vector),
            "::",
            stringify!(__vctr)
        )
    );
}
pub type duckdb_vector = *mut _duckdb_vector;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _duckdb_value {
    pub __val: *mut ::std::os::raw::c_void,
}
#[test]
fn bindgen_test_layout__duckdb_value() {
    const UNINIT: ::std::mem::MaybeUninit<_duckdb_value> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_duckdb_value>(),
        8usize,
        concat!("Size of: ", stringify!(_duckdb_value))
    );
    assert_eq!(
        ::std::mem::align_of::<_duckdb_value>(),
        8usize,
        concat!("Alignment of ", stringify!(_duckdb_value))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__val) as usize - ptr as usize },
        0usize,
        concat!("Offset of field: ", stringify!(_duckdb_value), "::", stringify!(__val))
    );
}
pub type duckdb_value = *mut _duckdb_value;
pub const duckdb_state_DuckDBSuccess: duckdb_state = 0;
pub const duckdb_state_DuckDBError: duckdb_state = 1;
pub type duckdb_state = ::std::os::raw::c_uint;
pub const duckdb_pending_state_DUCKDB_PENDING_RESULT_READY: duckdb_pending_state = 0;
pub const duckdb_pending_state_DUCKDB_PENDING_RESULT_NOT_READY: duckdb_pending_state = 1;
pub const duckdb_pending_state_DUCKDB_PENDING_ERROR: duckdb_pending_state = 2;
pub type duckdb_pending_state = ::std::os::raw::c_uint;
extern "C" {
    #[doc = "Creates a new database or opens an existing database file stored at the the given path.\nIf no path is given a new in-memory database is created instead.\nThe instantiated database should be closed with 'duckdb_close'\n\n path: Path to the database file on disk, or `nullptr` or `:memory:` to open an in-memory database.\n out_database: The result database object.\n returns: `DuckDBSuccess` on success or `DuckDBError` on failure."]
    pub fn duckdb_open(path: *const ::std::os::raw::c_char, out_database: *mut duckdb_database) -> duckdb_state;
}
extern "C" {
    #[doc = "Extended version of duckdb_open. Creates a new database or opens an existing database file stored at the the given path.\n\n path: Path to the database file on disk, or `nullptr` or `:memory:` to open an in-memory database.\n out_database: The result database object.\n config: (Optional) configuration used to start up the database system.\n out_error: If set and the function returns DuckDBError, this will contain the reason why the start-up failed.\nNote that the error must be freed using `duckdb_free`.\n returns: `DuckDBSuccess` on success or `DuckDBError` on failure."]
    pub fn duckdb_open_ext(
        path: *const ::std::os::raw::c_char,
        out_database: *mut duckdb_database,
        config: duckdb_config,
        out_error: *mut *mut ::std::os::raw::c_char,
    ) -> duckdb_state;
}
extern "C" {
    #[doc = "Closes the specified database and de-allocates all memory allocated for that database.\nThis should be called after you are done with any database allocated through `duckdb_open`.\nNote that failing to call `duckdb_close` (in case of e.g. a program crash) will not cause data corruption.\nStill it is recommended to always correctly close a database object after you are done with it.\n\n database: The database object to shut down."]
    pub fn duckdb_close(database: *mut duckdb_database);
}
extern "C" {
    #[doc = "Opens a connection to a database. Connections are required to query the database, and store transactional state\nassociated with the connection.\nThe instantiated connection should be closed using 'duckdb_disconnect'\n\n database: The database file to connect to.\n out_connection: The result connection object.\n returns: `DuckDBSuccess` on success or `DuckDBError` on failure."]
    pub fn duckdb_connect(database: duckdb_database, out_connection: *mut duckdb_connection) -> duckdb_state;
}
extern "C" {
    #[doc = "Closes the specified connection and de-allocates all memory allocated for that connection.\n\n connection: The connection to close."]
    pub fn duckdb_disconnect(connection: *mut duckdb_connection);
}
extern "C" {
    #[doc = "Returns the version of the linked DuckDB, with a version postfix for dev versions\n\nUsually used for developing C extensions that must return this for a compatibility check."]
    pub fn duckdb_library_version() -> *const ::std::os::raw::c_char;
}
extern "C" {
    #[doc = "Initializes an empty configuration object that can be used to provide start-up options for the DuckDB instance\nthrough `duckdb_open_ext`.\n\nThis will always succeed unless there is a malloc failure.\n\n out_config: The result configuration object.\n returns: `DuckDBSuccess` on success or `DuckDBError` on failure."]
    pub fn duckdb_create_config(out_config: *mut duckdb_config) -> duckdb_state;
}
extern "C" {
    #[doc = "This returns the total amount of configuration options available for usage with `duckdb_get_config_flag`.\n\nThis should not be called in a loop as it internally loops over all the options.\n\n returns: The amount of config options available."]
    pub fn duckdb_config_count() -> usize;
}
extern "C" {
    #[doc = "Obtains a human-readable name and description of a specific configuration option. This can be used to e.g.\ndisplay configuration options. This will succeed unless `index` is out of range (i.e. `>= duckdb_config_count`).\n\nThe result name or description MUST NOT be freed.\n\n index: The index of the configuration option (between 0 and `duckdb_config_count`)\n out_name: A name of the configuration flag.\n out_description: A description of the configuration flag.\n returns: `DuckDBSuccess` on success or `DuckDBError` on failure."]
    pub fn duckdb_get_config_flag(
        index: usize,
        out_name: *mut *const ::std::os::raw::c_char,
        out_description: *mut *const ::std::os::raw::c_char,
    ) -> duckdb_state;
}
extern "C" {
    #[doc = "Sets the specified option for the specified configuration. The configuration option is indicated by name.\nTo obtain a list of config options, see `duckdb_get_config_flag`.\n\nIn the source code, configuration options are defined in `config.cpp`.\n\nThis can fail if either the name is invalid, or if the value provided for the option is invalid.\n\n duckdb_config: The configuration object to set the option on.\n name: The name of the configuration flag to set.\n option: The value to set the configuration flag to.\n returns: `DuckDBSuccess` on success or `DuckDBError` on failure."]
    pub fn duckdb_set_config(
        config: duckdb_config,
        name: *const ::std::os::raw::c_char,
        option: *const ::std::os::raw::c_char,
    ) -> duckdb_state;
}
extern "C" {
    #[doc = "Destroys the specified configuration option and de-allocates all memory allocated for the object.\n\n config: The configuration object to destroy."]
    pub fn duckdb_destroy_config(config: *mut duckdb_config);
}
extern "C" {
    #[doc = "Executes a SQL query within a connection and stores the full (materialized) result in the out_result pointer.\nIf the query fails to execute, DuckDBError is returned and the error message can be retrieved by calling\n`duckdb_result_error`.\n\nNote that after running `duckdb_query`, `duckdb_destroy_result` must be called on the result object even if the\nquery fails, otherwise the error stored within the result will not be freed correctly.\n\n connection: The connection to perform the query in.\n query: The SQL query to run.\n out_result: The query result.\n returns: `DuckDBSuccess` on success or `DuckDBError` on failure."]
    pub fn duckdb_query(
        connection: duckdb_connection,
        query: *const ::std::os::raw::c_char,
        out_result: *mut duckdb_result,
    ) -> duckdb_state;
}
extern "C" {
    #[doc = "Closes the result and de-allocates all memory allocated for that connection.\n\n result: The result to destroy."]
    pub fn duckdb_destroy_result(result: *mut duckdb_result);
}
extern "C" {
    #[doc = "Returns the column name of the specified column. The result should not need be freed; the column names will\nautomatically be destroyed when the result is destroyed.\n\nReturns `NULL` if the column is out of range.\n\n result: The result object to fetch the column name from.\n col: The column index.\n returns: The column name of the specified column."]
    pub fn duckdb_column_name(result: *mut duckdb_result, col: idx_t) -> *const ::std::os::raw::c_char;
}
extern "C" {
    #[doc = "Returns the column type of the specified column.\n\nReturns `DUCKDB_TYPE_INVALID` if the column is out of range.\n\n result: The result object to fetch the column type from.\n col: The column index.\n returns: The column type of the specified column."]
    pub fn duckdb_column_type(result: *mut duckdb_result, col: idx_t) -> duckdb_type;
}
extern "C" {
    #[doc = "Returns the logical column type of the specified column.\n\nThe return type of this call should be destroyed with `duckdb_destroy_logical_type`.\n\nReturns `NULL` if the column is out of range.\n\n result: The result object to fetch the column type from.\n col: The column index.\n returns: The logical column type of the specified column."]
    pub fn duckdb_column_logical_type(result: *mut duckdb_result, col: idx_t) -> duckdb_logical_type;
}
extern "C" {
    #[doc = "Returns the number of columns present in a the result object.\n\n result: The result object.\n returns: The number of columns present in the result object."]
    pub fn duckdb_column_count(result: *mut duckdb_result) -> idx_t;
}
extern "C" {
    #[doc = "Returns the number of rows present in a the result object.\n\n result: The result object.\n returns: The number of rows present in the result object."]
    pub fn duckdb_row_count(result: *mut duckdb_result) -> idx_t;
}
extern "C" {
    #[doc = "Returns the number of rows changed by the query stored in the result. This is relevant only for INSERT/UPDATE/DELETE\nqueries. For other queries the rows_changed will be 0.\n\n result: The result object.\n returns: The number of rows changed."]
    pub fn duckdb_rows_changed(result: *mut duckdb_result) -> idx_t;
}
extern "C" {
    #[doc = "DEPRECATED**: Prefer using `duckdb_result_get_chunk` instead.\n\nReturns the data of a specific column of a result in columnar format.\n\nThe function returns a dense array which contains the result data. The exact type stored in the array depends on the\ncorresponding duckdb_type (as provided by `duckdb_column_type`). For the exact type by which the data should be\naccessed, see the comments in [the types section](types) or the `DUCKDB_TYPE` enum.\n\nFor example, for a column of type `DUCKDB_TYPE_INTEGER`, rows can be accessed in the following manner:\n```c\nint32_t *data = (int32_t *) duckdb_column_data(&result, 0);\nprintf(\"Data for row %d: %d\\n\", row, data[row]);\n```\n\n result: The result object to fetch the column data from.\n col: The column index.\n returns: The column data of the specified column."]
    pub fn duckdb_column_data(result: *mut duckdb_result, col: idx_t) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    #[doc = "DEPRECATED**: Prefer using `duckdb_result_get_chunk` instead.\n\nReturns the nullmask of a specific column of a result in columnar format. The nullmask indicates for every row\nwhether or not the corresponding row is `NULL`. If a row is `NULL`, the values present in the array provided\nby `duckdb_column_data` are undefined.\n\n```c\nint32_t *data = (int32_t *) duckdb_column_data(&result, 0);\nbool *nullmask = duckdb_nullmask_data(&result, 0);\nif (nullmask[row]) {\nprintf(\"Data for row %d: NULL\\n\", row);\n} else {\nprintf(\"Data for row %d: %d\\n\", row, data[row]);\n}\n```\n\n result: The result object to fetch the nullmask from.\n col: The column index.\n returns: The nullmask of the specified column."]
    pub fn duckdb_nullmask_data(result: *mut duckdb_result, col: idx_t) -> *mut bool;
}
extern "C" {
    #[doc = "Returns the error message contained within the result. The error is only set if `duckdb_query` returns `DuckDBError`.\n\nThe result of this function must not be freed. It will be cleaned up when `duckdb_destroy_result` is called.\n\n result: The result object to fetch the error from.\n returns: The error of the result."]
    pub fn duckdb_result_error(result: *mut duckdb_result) -> *const ::std::os::raw::c_char;
}
extern "C" {
    #[doc = "Fetches a data chunk from the duckdb_result. This function should be called repeatedly until the result is exhausted.\n\nThe result must be destroyed with `duckdb_destroy_data_chunk`.\n\nThis function supersedes all `duckdb_value` functions, as well as the `duckdb_column_data` and `duckdb_nullmask_data`\nfunctions. It results in significantly better performance, and should be preferred in newer code-bases.\n\nIf this function is used, none of the other result functions can be used and vice versa (i.e. this function cannot be\nmixed with the legacy result functions).\n\nUse `duckdb_result_chunk_count` to figure out how many chunks there are in the result.\n\n result: The result object to fetch the data chunk from.\n chunk_index: The chunk index to fetch from.\n returns: The resulting data chunk. Returns `NULL` if the chunk index is out of bounds."]
    pub fn duckdb_result_get_chunk(result: duckdb_result, chunk_index: idx_t) -> duckdb_data_chunk;
}
extern "C" {
    #[doc = "Checks if the type of the internal result is StreamQueryResult.\n\n result: The result object to check.\n returns: Whether or not the result object is of the type StreamQueryResult"]
    pub fn duckdb_result_is_streaming(result: duckdb_result) -> bool;
}
extern "C" {
    #[doc = "Returns the number of data chunks present in the result.\n\n result: The result object\n returns: Number of data chunks present in the result."]
    pub fn duckdb_result_chunk_count(result: duckdb_result) -> idx_t;
}
extern "C" {
    #[doc = " returns: The boolean value at the specified location, or false if the value cannot be converted."]
    pub fn duckdb_value_boolean(result: *mut duckdb_result, col: idx_t, row: idx_t) -> bool;
}
extern "C" {
    #[doc = " returns: The int8_t value at the specified location, or 0 if the value cannot be converted."]
    pub fn duckdb_value_int8(result: *mut duckdb_result, col: idx_t, row: idx_t) -> i8;
}
extern "C" {
    #[doc = " returns: The int16_t value at the specified location, or 0 if the value cannot be converted."]
    pub fn duckdb_value_int16(result: *mut duckdb_result, col: idx_t, row: idx_t) -> i16;
}
extern "C" {
    #[doc = " returns: The int32_t value at the specified location, or 0 if the value cannot be converted."]
    pub fn duckdb_value_int32(result: *mut duckdb_result, col: idx_t, row: idx_t) -> i32;
}
extern "C" {
    #[doc = " returns: The int64_t value at the specified location, or 0 if the value cannot be converted."]
    pub fn duckdb_value_int64(result: *mut duckdb_result, col: idx_t, row: idx_t) -> i64;
}
extern "C" {
    #[doc = " returns: The duckdb_hugeint value at the specified location, or 0 if the value cannot be converted."]
    pub fn duckdb_value_hugeint(result: *mut duckdb_result, col: idx_t, row: idx_t) -> duckdb_hugeint;
}
extern "C" {
    #[doc = " returns: The duckdb_decimal value at the specified location, or 0 if the value cannot be converted."]
    pub fn duckdb_value_decimal(result: *mut duckdb_result, col: idx_t, row: idx_t) -> duckdb_decimal;
}
extern "C" {
    #[doc = " returns: The uint8_t value at the specified location, or 0 if the value cannot be converted."]
    pub fn duckdb_value_uint8(result: *mut duckdb_result, col: idx_t, row: idx_t) -> u8;
}
extern "C" {
    #[doc = " returns: The uint16_t value at the specified location, or 0 if the value cannot be converted."]
    pub fn duckdb_value_uint16(result: *mut duckdb_result, col: idx_t, row: idx_t) -> u16;
}
extern "C" {
    #[doc = " returns: The uint32_t value at the specified location, or 0 if the value cannot be converted."]
    pub fn duckdb_value_uint32(result: *mut duckdb_result, col: idx_t, row: idx_t) -> u32;
}
extern "C" {
    #[doc = " returns: The uint64_t value at the specified location, or 0 if the value cannot be converted."]
    pub fn duckdb_value_uint64(result: *mut duckdb_result, col: idx_t, row: idx_t) -> u64;
}
extern "C" {
    #[doc = " returns: The float value at the specified location, or 0 if the value cannot be converted."]
    pub fn duckdb_value_float(result: *mut duckdb_result, col: idx_t, row: idx_t) -> f32;
}
extern "C" {
    #[doc = " returns: The double value at the specified location, or 0 if the value cannot be converted."]
    pub fn duckdb_value_double(result: *mut duckdb_result, col: idx_t, row: idx_t) -> f64;
}
extern "C" {
    #[doc = " returns: The duckdb_date value at the specified location, or 0 if the value cannot be converted."]
    pub fn duckdb_value_date(result: *mut duckdb_result, col: idx_t, row: idx_t) -> duckdb_date;
}
extern "C" {
    #[doc = " returns: The duckdb_time value at the specified location, or 0 if the value cannot be converted."]
    pub fn duckdb_value_time(result: *mut duckdb_result, col: idx_t, row: idx_t) -> duckdb_time;
}
extern "C" {
    #[doc = " returns: The duckdb_timestamp value at the specified location, or 0 if the value cannot be converted."]
    pub fn duckdb_value_timestamp(result: *mut duckdb_result, col: idx_t, row: idx_t) -> duckdb_timestamp;
}
extern "C" {
    #[doc = " returns: The duckdb_interval value at the specified location, or 0 if the value cannot be converted."]
    pub fn duckdb_value_interval(result: *mut duckdb_result, col: idx_t, row: idx_t) -> duckdb_interval;
}
extern "C" {
    #[doc = " DEPRECATED: use duckdb_value_string instead. This function does not work correctly if the string contains null bytes.\n returns: The text value at the specified location as a null-terminated string, or nullptr if the value cannot be\nconverted. The result must be freed with `duckdb_free`."]
    pub fn duckdb_value_varchar(result: *mut duckdb_result, col: idx_t, row: idx_t) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    #[doc = "s\n returns: The string value at the specified location.\nThe result must be freed with `duckdb_free`."]
    pub fn duckdb_value_string(result: *mut duckdb_result, col: idx_t, row: idx_t) -> duckdb_string;
}
extern "C" {
    #[doc = " DEPRECATED: use duckdb_value_string_internal instead. This function does not work correctly if the string contains\nnull bytes.\n returns: The char* value at the specified location. ONLY works on VARCHAR columns and does not auto-cast.\nIf the column is NOT a VARCHAR column this function will return NULL.\n\nThe result must NOT be freed."]
    pub fn duckdb_value_varchar_internal(
        result: *mut duckdb_result,
        col: idx_t,
        row: idx_t,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    #[doc = " DEPRECATED: use duckdb_value_string_internal instead. This function does not work correctly if the string contains\nnull bytes.\n returns: The char* value at the specified location. ONLY works on VARCHAR columns and does not auto-cast.\nIf the column is NOT a VARCHAR column this function will return NULL.\n\nThe result must NOT be freed."]
    pub fn duckdb_value_string_internal(result: *mut duckdb_result, col: idx_t, row: idx_t) -> duckdb_string;
}
extern "C" {
    #[doc = " returns: The duckdb_blob value at the specified location. Returns a blob with blob.data set to nullptr if the\nvalue cannot be converted. The resulting \"blob.data\" must be freed with `duckdb_free.`"]
    pub fn duckdb_value_blob(result: *mut duckdb_result, col: idx_t, row: idx_t) -> duckdb_blob;
}
extern "C" {
    #[doc = " returns: Returns true if the value at the specified index is NULL, and false otherwise."]
    pub fn duckdb_value_is_null(result: *mut duckdb_result, col: idx_t, row: idx_t) -> bool;
}
extern "C" {
    #[doc = "Allocate `size` bytes of memory using the duckdb internal malloc function. Any memory allocated in this manner\nshould be freed using `duckdb_free`.\n\n size: The number of bytes to allocate.\n returns: A pointer to the allocated memory region."]
    pub fn duckdb_malloc(size: usize) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    #[doc = "Free a value returned from `duckdb_malloc`, `duckdb_value_varchar` or `duckdb_value_blob`.\n\n ptr: The memory region to de-allocate."]
    pub fn duckdb_free(ptr: *mut ::std::os::raw::c_void);
}
extern "C" {
    #[doc = "The internal vector size used by DuckDB.\nThis is the amount of tuples that will fit into a data chunk created by `duckdb_create_data_chunk`.\n\n returns: The vector size."]
    pub fn duckdb_vector_size() -> idx_t;
}
extern "C" {
    #[doc = "Whether or not the duckdb_string_t value is inlined.\nThis means that the data of the string does not have a separate allocation."]
    pub fn duckdb_string_is_inlined(string: duckdb_string_t) -> bool;
}
extern "C" {
    #[doc = "Decompose a `duckdb_date` object into year, month and date (stored as `duckdb_date_struct`).\n\n date: The date object, as obtained from a `DUCKDB_TYPE_DATE` column.\n returns: The `duckdb_date_struct` with the decomposed elements."]
    pub fn duckdb_from_date(date: duckdb_date) -> duckdb_date_struct;
}
extern "C" {
    #[doc = "Re-compose a `duckdb_date` from year, month and date (`duckdb_date_struct`).\n\n date: The year, month and date stored in a `duckdb_date_struct`.\n returns: The `duckdb_date` element."]
    pub fn duckdb_to_date(date: duckdb_date_struct) -> duckdb_date;
}
extern "C" {
    #[doc = "Decompose a `duckdb_time` object into hour, minute, second and microsecond (stored as `duckdb_time_struct`).\n\n time: The time object, as obtained from a `DUCKDB_TYPE_TIME` column.\n returns: The `duckdb_time_struct` with the decomposed elements."]
    pub fn duckdb_from_time(time: duckdb_time) -> duckdb_time_struct;
}
extern "C" {
    #[doc = "Re-compose a `duckdb_time` from hour, minute, second and microsecond (`duckdb_time_struct`).\n\n time: The hour, minute, second and microsecond in a `duckdb_time_struct`.\n returns: The `duckdb_time` element."]
    pub fn duckdb_to_time(time: duckdb_time_struct) -> duckdb_time;
}
extern "C" {
    #[doc = "Decompose a `duckdb_timestamp` object into a `duckdb_timestamp_struct`.\n\n ts: The ts object, as obtained from a `DUCKDB_TYPE_TIMESTAMP` column.\n returns: The `duckdb_timestamp_struct` with the decomposed elements."]
    pub fn duckdb_from_timestamp(ts: duckdb_timestamp) -> duckdb_timestamp_struct;
}
extern "C" {
    #[doc = "Re-compose a `duckdb_timestamp` from a duckdb_timestamp_struct.\n\n ts: The de-composed elements in a `duckdb_timestamp_struct`.\n returns: The `duckdb_timestamp` element."]
    pub fn duckdb_to_timestamp(ts: duckdb_timestamp_struct) -> duckdb_timestamp;
}
extern "C" {
    #[doc = "Converts a duckdb_hugeint object (as obtained from a `DUCKDB_TYPE_HUGEINT` column) into a double.\n\n val: The hugeint value.\n returns: The converted `double` element."]
    pub fn duckdb_hugeint_to_double(val: duckdb_hugeint) -> f64;
}
extern "C" {
    #[doc = "Converts a double value to a duckdb_hugeint object.\n\nIf the conversion fails because the double value is too big the result will be 0.\n\n val: The double value.\n returns: The converted `duckdb_hugeint` element."]
    pub fn duckdb_double_to_hugeint(val: f64) -> duckdb_hugeint;
}
extern "C" {
    #[doc = "Converts a double value to a duckdb_decimal object.\n\nIf the conversion fails because the double value is too big, or the width/scale are invalid the result will be 0.\n\n val: The double value.\n returns: The converted `duckdb_decimal` element."]
    pub fn duckdb_double_to_decimal(val: f64, width: u8, scale: u8) -> duckdb_decimal;
}
extern "C" {
    #[doc = "Converts a duckdb_decimal object (as obtained from a `DUCKDB_TYPE_DECIMAL` column) into a double.\n\n val: The decimal value.\n returns: The converted `double` element."]
    pub fn duckdb_decimal_to_double(val: duckdb_decimal) -> f64;
}
extern "C" {
    #[doc = "Create a prepared statement object from a query.\n\nNote that after calling `duckdb_prepare`, the prepared statement should always be destroyed using\n`duckdb_destroy_prepare`, even if the prepare fails.\n\nIf the prepare fails, `duckdb_prepare_error` can be called to obtain the reason why the prepare failed.\n\n connection: The connection object\n query: The SQL query to prepare\n out_prepared_statement: The resulting prepared statement object\n returns: `DuckDBSuccess` on success or `DuckDBError` on failure."]
    pub fn duckdb_prepare(
        connection: duckdb_connection,
        query: *const ::std::os::raw::c_char,
        out_prepared_statement: *mut duckdb_prepared_statement,
    ) -> duckdb_state;
}
extern "C" {
    #[doc = "Closes the prepared statement and de-allocates all memory allocated for the statement.\n\n prepared_statement: The prepared statement to destroy."]
    pub fn duckdb_destroy_prepare(prepared_statement: *mut duckdb_prepared_statement);
}
extern "C" {
    #[doc = "Returns the error message associated with the given prepared statement.\nIf the prepared statement has no error message, this returns `nullptr` instead.\n\nThe error message should not be freed. It will be de-allocated when `duckdb_destroy_prepare` is called.\n\n prepared_statement: The prepared statement to obtain the error from.\n returns: The error message, or `nullptr` if there is none."]
    pub fn duckdb_prepare_error(prepared_statement: duckdb_prepared_statement) -> *const ::std::os::raw::c_char;
}
extern "C" {
    #[doc = "Returns the number of parameters that can be provided to the given prepared statement.\n\nReturns 0 if the query was not successfully prepared.\n\n prepared_statement: The prepared statement to obtain the number of parameters for."]
    pub fn duckdb_nparams(prepared_statement: duckdb_prepared_statement) -> idx_t;
}
extern "C" {
    #[doc = "Returns the parameter type for the parameter at the given index.\n\nReturns `DUCKDB_TYPE_INVALID` if the parameter index is out of range or the statement was not successfully prepared.\n\n prepared_statement: The prepared statement.\n param_idx: The parameter index.\n returns: The parameter type"]
    pub fn duckdb_param_type(prepared_statement: duckdb_prepared_statement, param_idx: idx_t) -> duckdb_type;
}
extern "C" {
    #[doc = "Clear the params bind to the prepared statement."]
    pub fn duckdb_clear_bindings(prepared_statement: duckdb_prepared_statement) -> duckdb_state;
}
extern "C" {
    #[doc = "Binds a bool value to the prepared statement at the specified index."]
    pub fn duckdb_bind_boolean(
        prepared_statement: duckdb_prepared_statement,
        param_idx: idx_t,
        val: bool,
    ) -> duckdb_state;
}
extern "C" {
    #[doc = "Binds an int8_t value to the prepared statement at the specified index."]
    pub fn duckdb_bind_int8(prepared_statement: duckdb_prepared_statement, param_idx: idx_t, val: i8) -> duckdb_state;
}
extern "C" {
    #[doc = "Binds an int16_t value to the prepared statement at the specified index."]
    pub fn duckdb_bind_int16(prepared_statement: duckdb_prepared_statement, param_idx: idx_t, val: i16)
        -> duckdb_state;
}
extern "C" {
    #[doc = "Binds an int32_t value to the prepared statement at the specified index."]
    pub fn duckdb_bind_int32(prepared_statement: duckdb_prepared_statement, param_idx: idx_t, val: i32)
        -> duckdb_state;
}
extern "C" {
    #[doc = "Binds an int64_t value to the prepared statement at the specified index."]
    pub fn duckdb_bind_int64(prepared_statement: duckdb_prepared_statement, param_idx: idx_t, val: i64)
        -> duckdb_state;
}
extern "C" {
    #[doc = "Binds an duckdb_hugeint value to the prepared statement at the specified index."]
    pub fn duckdb_bind_hugeint(
        prepared_statement: duckdb_prepared_statement,
        param_idx: idx_t,
        val: duckdb_hugeint,
    ) -> duckdb_state;
}
extern "C" {
    #[doc = "Binds a duckdb_decimal value to the prepared statement at the specified index."]
    pub fn duckdb_bind_decimal(
        prepared_statement: duckdb_prepared_statement,
        param_idx: idx_t,
        val: duckdb_decimal,
    ) -> duckdb_state;
}
extern "C" {
    #[doc = "Binds an uint8_t value to the prepared statement at the specified index."]
    pub fn duckdb_bind_uint8(prepared_statement: duckdb_prepared_statement, param_idx: idx_t, val: u8) -> duckdb_state;
}
extern "C" {
    #[doc = "Binds an uint16_t value to the prepared statement at the specified index."]
    pub fn duckdb_bind_uint16(
        prepared_statement: duckdb_prepared_statement,
        param_idx: idx_t,
        val: u16,
    ) -> duckdb_state;
}
extern "C" {
    #[doc = "Binds an uint32_t value to the prepared statement at the specified index."]
    pub fn duckdb_bind_uint32(
        prepared_statement: duckdb_prepared_statement,
        param_idx: idx_t,
        val: u32,
    ) -> duckdb_state;
}
extern "C" {
    #[doc = "Binds an uint64_t value to the prepared statement at the specified index."]
    pub fn duckdb_bind_uint64(
        prepared_statement: duckdb_prepared_statement,
        param_idx: idx_t,
        val: u64,
    ) -> duckdb_state;
}
extern "C" {
    #[doc = "Binds an float value to the prepared statement at the specified index."]
    pub fn duckdb_bind_float(prepared_statement: duckdb_prepared_statement, param_idx: idx_t, val: f32)
        -> duckdb_state;
}
extern "C" {
    #[doc = "Binds an double value to the prepared statement at the specified index."]
    pub fn duckdb_bind_double(
        prepared_statement: duckdb_prepared_statement,
        param_idx: idx_t,
        val: f64,
    ) -> duckdb_state;
}
extern "C" {
    #[doc = "Binds a duckdb_date value to the prepared statement at the specified index."]
    pub fn duckdb_bind_date(
        prepared_statement: duckdb_prepared_statement,
        param_idx: idx_t,
        val: duckdb_date,
    ) -> duckdb_state;
}
extern "C" {
    #[doc = "Binds a duckdb_time value to the prepared statement at the specified index."]
    pub fn duckdb_bind_time(
        prepared_statement: duckdb_prepared_statement,
        param_idx: idx_t,
        val: duckdb_time,
    ) -> duckdb_state;
}
extern "C" {
    #[doc = "Binds a duckdb_timestamp value to the prepared statement at the specified index."]
    pub fn duckdb_bind_timestamp(
        prepared_statement: duckdb_prepared_statement,
        param_idx: idx_t,
        val: duckdb_timestamp,
    ) -> duckdb_state;
}
extern "C" {
    #[doc = "Binds a duckdb_interval value to the prepared statement at the specified index."]
    pub fn duckdb_bind_interval(
        prepared_statement: duckdb_prepared_statement,
        param_idx: idx_t,
        val: duckdb_interval,
    ) -> duckdb_state;
}
extern "C" {
    #[doc = "Binds a null-terminated varchar value to the prepared statement at the specified index."]
    pub fn duckdb_bind_varchar(
        prepared_statement: duckdb_prepared_statement,
        param_idx: idx_t,
        val: *const ::std::os::raw::c_char,
    ) -> duckdb_state;
}
extern "C" {
    #[doc = "Binds a varchar value to the prepared statement at the specified index."]
    pub fn duckdb_bind_varchar_length(
        prepared_statement: duckdb_prepared_statement,
        param_idx: idx_t,
        val: *const ::std::os::raw::c_char,
        length: idx_t,
    ) -> duckdb_state;
}
extern "C" {
    #[doc = "Binds a blob value to the prepared statement at the specified index."]
    pub fn duckdb_bind_blob(
        prepared_statement: duckdb_prepared_statement,
        param_idx: idx_t,
        data: *const ::std::os::raw::c_void,
        length: idx_t,
    ) -> duckdb_state;
}
extern "C" {
    #[doc = "Binds a NULL value to the prepared statement at the specified index."]
    pub fn duckdb_bind_null(prepared_statement: duckdb_prepared_statement, param_idx: idx_t) -> duckdb_state;
}
extern "C" {
    #[doc = "Executes the prepared statement with the given bound parameters, and returns a materialized query result.\n\nThis method can be called multiple times for each prepared statement, and the parameters can be modified\nbetween calls to this function.\n\n prepared_statement: The prepared statement to execute.\n out_result: The query result.\n returns: `DuckDBSuccess` on success or `DuckDBError` on failure."]
    pub fn duckdb_execute_prepared(
        prepared_statement: duckdb_prepared_statement,
        out_result: *mut duckdb_result,
    ) -> duckdb_state;
}
extern "C" {
    #[doc = "Executes the prepared statement with the given bound parameters, and returns an arrow query result.\n\n prepared_statement: The prepared statement to execute.\n out_result: The query result.\n returns: `DuckDBSuccess` on success or `DuckDBError` on failure."]
    pub fn duckdb_execute_prepared_arrow(
        prepared_statement: duckdb_prepared_statement,
        out_result: *mut duckdb_arrow,
    ) -> duckdb_state;
}
extern "C" {
    #[doc = "Extract all statements from a query.\nNote that after calling `duckdb_extract_statements`, the extracted statements should always be destroyed using\n`duckdb_destroy_extracted`, even if no statements were extracted.\nIf the extract fails, `duckdb_extract_statements_error` can be called to obtain the reason why the extract failed.\n connection: The connection object\n query: The SQL query to extract\n out_extracted_statements: The resulting extracted statements object\n returns: The number of extracted statements or 0 on failure."]
    pub fn duckdb_extract_statements(
        connection: duckdb_connection,
        query: *const ::std::os::raw::c_char,
        out_extracted_statements: *mut duckdb_extracted_statements,
    ) -> idx_t;
}
extern "C" {
    #[doc = "Prepare an extracted statement.\nNote that after calling `duckdb_prepare_extracted_statement`, the prepared statement should always be destroyed using\n`duckdb_destroy_prepare`, even if the prepare fails.\nIf the prepare fails, `duckdb_prepare_error` can be called to obtain the reason why the prepare failed.\n connection: The connection object\n extracted_statements: The extracted statements object\n index: The index of the extracted statement to prepare\n out_prepared_statement: The resulting prepared statement object\n returns: `DuckDBSuccess` on success or `DuckDBError` on failure."]
    pub fn duckdb_prepare_extracted_statement(
        connection: duckdb_connection,
        extracted_statements: duckdb_extracted_statements,
        index: idx_t,
        out_prepared_statement: *mut duckdb_prepared_statement,
    ) -> duckdb_state;
}
extern "C" {
    #[doc = "Returns the error message contained within the extracted statements.\nThe result of this function must not be freed. It will be cleaned up when `duckdb_destroy_extracted` is called.\n result: The extracted statements to fetch the error from.\n returns: The error of the extracted statements."]
    pub fn duckdb_extract_statements_error(
        extracted_statements: duckdb_extracted_statements,
    ) -> *const ::std::os::raw::c_char;
}
extern "C" {
    #[doc = "De-allocates all memory allocated for the extracted statements.\n extracted_statements: The extracted statements to destroy."]
    pub fn duckdb_destroy_extracted(extracted_statements: *mut duckdb_extracted_statements);
}
extern "C" {
    #[doc = "Executes the prepared statement with the given bound parameters, and returns a pending result.\nThe pending result represents an intermediate structure for a query that is not yet fully executed.\nThe pending result can be used to incrementally execute a query, returning control to the client between tasks.\n\nNote that after calling `duckdb_pending_prepared`, the pending result should always be destroyed using\n`duckdb_destroy_pending`, even if this function returns DuckDBError.\n\n prepared_statement: The prepared statement to execute.\n out_result: The pending query result.\n returns: `DuckDBSuccess` on success or `DuckDBError` on failure."]
    pub fn duckdb_pending_prepared(
        prepared_statement: duckdb_prepared_statement,
        out_result: *mut duckdb_pending_result,
    ) -> duckdb_state;
}
extern "C" {
    #[doc = "Executes the prepared statement with the given bound parameters, and returns a pending result.\nThis pending result will create a streaming duckdb_result when executed.\nThe pending result represents an intermediate structure for a query that is not yet fully executed.\n\nNote that after calling `duckdb_pending_prepared_streaming`, the pending result should always be destroyed using\n`duckdb_destroy_pending`, even if this function returns DuckDBError.\n\n prepared_statement: The prepared statement to execute.\n out_result: The pending query result.\n returns: `DuckDBSuccess` on success or `DuckDBError` on failure."]
    pub fn duckdb_pending_prepared_streaming(
        prepared_statement: duckdb_prepared_statement,
        out_result: *mut duckdb_pending_result,
    ) -> duckdb_state;
}
extern "C" {
    #[doc = "Closes the pending result and de-allocates all memory allocated for the result.\n\n pending_result: The pending result to destroy."]
    pub fn duckdb_destroy_pending(pending_result: *mut duckdb_pending_result);
}
extern "C" {
    #[doc = "Returns the error message contained within the pending result.\n\nThe result of this function must not be freed. It will be cleaned up when `duckdb_destroy_pending` is called.\n\n result: The pending result to fetch the error from.\n returns: The error of the pending result."]
    pub fn duckdb_pending_error(pending_result: duckdb_pending_result) -> *const ::std::os::raw::c_char;
}
extern "C" {
    #[doc = "Executes a single task within the query, returning whether or not the query is ready.\n\nIf this returns DUCKDB_PENDING_RESULT_READY, the duckdb_execute_pending function can be called to obtain the result.\nIf this returns DUCKDB_PENDING_RESULT_NOT_READY, the duckdb_pending_execute_task function should be called again.\nIf this returns DUCKDB_PENDING_ERROR, an error occurred during execution.\n\nThe error message can be obtained by calling duckdb_pending_error on the pending_result.\n\n pending_result: The pending result to execute a task within..\n returns: The state of the pending result after the execution."]
    pub fn duckdb_pending_execute_task(pending_result: duckdb_pending_result) -> duckdb_pending_state;
}
extern "C" {
    #[doc = "Fully execute a pending query result, returning the final query result.\n\nIf duckdb_pending_execute_task has been called until DUCKDB_PENDING_RESULT_READY was returned, this will return fast.\nOtherwise, all remaining tasks must be executed first.\n\n pending_result: The pending result to execute.\n out_result: The result object.\n returns: `DuckDBSuccess` on success or `DuckDBError` on failure."]
    pub fn duckdb_execute_pending(
        pending_result: duckdb_pending_result,
        out_result: *mut duckdb_result,
    ) -> duckdb_state;
}
extern "C" {
    #[doc = "Destroys the value and de-allocates all memory allocated for that type.\n\n value: The value to destroy."]
    pub fn duckdb_destroy_value(value: *mut duckdb_value);
}
extern "C" {
    #[doc = "Creates a value from a null-terminated string\n\n value: The null-terminated string\n returns: The value. This must be destroyed with `duckdb_destroy_value`."]
    pub fn duckdb_create_varchar(text: *const ::std::os::raw::c_char) -> duckdb_value;
}
extern "C" {
    #[doc = "Creates a value from a string\n\n value: The text\n length: The length of the text\n returns: The value. This must be destroyed with `duckdb_destroy_value`."]
    pub fn duckdb_create_varchar_length(text: *const ::std::os::raw::c_char, length: idx_t) -> duckdb_value;
}
extern "C" {
    #[doc = "Creates a value from an int64\n\n value: The bigint value\n returns: The value. This must be destroyed with `duckdb_destroy_value`."]
    pub fn duckdb_create_int64(val: i64) -> duckdb_value;
}
extern "C" {
    #[doc = "Obtains a string representation of the given value.\nThe result must be destroyed with `duckdb_free`.\n\n value: The value\n returns: The string value. This must be destroyed with `duckdb_free`."]
    pub fn duckdb_get_varchar(value: duckdb_value) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    #[doc = "Obtains an int64 of the given value.\n\n value: The value\n returns: The int64 value, or 0 if no conversion is possible"]
    pub fn duckdb_get_int64(value: duckdb_value) -> i64;
}
extern "C" {
    #[doc = "Creates a `duckdb_logical_type` from a standard primitive type.\nThe resulting type should be destroyed with `duckdb_destroy_logical_type`.\n\nThis should not be used with `DUCKDB_TYPE_DECIMAL`.\n\n type: The primitive type to create.\n returns: The logical type."]
    pub fn duckdb_create_logical_type(type_: duckdb_type) -> duckdb_logical_type;
}
extern "C" {
    #[doc = "Creates a list type from its child type.\nThe resulting type should be destroyed with `duckdb_destroy_logical_type`.\n\n type: The child type of list type to create.\n returns: The logical type."]
    pub fn duckdb_create_list_type(type_: duckdb_logical_type) -> duckdb_logical_type;
}
extern "C" {
    #[doc = "Creates a map type from its key type and value type.\nThe resulting type should be destroyed with `duckdb_destroy_logical_type`.\n\n type: The key type and value type of map type to create.\n returns: The logical type."]
    pub fn duckdb_create_map_type(
        key_type: duckdb_logical_type,
        value_type: duckdb_logical_type,
    ) -> duckdb_logical_type;
}
extern "C" {
    #[doc = "Creates a UNION type from the passed types array\nThe resulting type should be destroyed with `duckdb_destroy_logical_type`.\n\n types: The array of types that the union should consist of.\n type_amount: The size of the types array.\n returns: The logical type."]
    pub fn duckdb_create_union_type(
        member_types: duckdb_logical_type,
        member_names: *mut *const ::std::os::raw::c_char,
        member_count: idx_t,
    ) -> duckdb_logical_type;
}
extern "C" {
    #[doc = "Creates a `duckdb_logical_type` of type decimal with the specified width and scale\nThe resulting type should be destroyed with `duckdb_destroy_logical_type`.\n\n width: The width of the decimal type\n scale: The scale of the decimal type\n returns: The logical type."]
    pub fn duckdb_create_decimal_type(width: u8, scale: u8) -> duckdb_logical_type;
}
extern "C" {
    #[doc = "Retrieves the type class of a `duckdb_logical_type`.\n\n type: The logical type object\n returns: The type id"]
    pub fn duckdb_get_type_id(type_: duckdb_logical_type) -> duckdb_type;
}
extern "C" {
    #[doc = "Retrieves the width of a decimal type.\n\n type: The logical type object\n returns: The width of the decimal type"]
    pub fn duckdb_decimal_width(type_: duckdb_logical_type) -> u8;
}
extern "C" {
    #[doc = "Retrieves the scale of a decimal type.\n\n type: The logical type object\n returns: The scale of the decimal type"]
    pub fn duckdb_decimal_scale(type_: duckdb_logical_type) -> u8;
}
extern "C" {
    #[doc = "Retrieves the internal storage type of a decimal type.\n\n type: The logical type object\n returns: The internal type of the decimal type"]
    pub fn duckdb_decimal_internal_type(type_: duckdb_logical_type) -> duckdb_type;
}
extern "C" {
    #[doc = "Retrieves the internal storage type of an enum type.\n\n type: The logical type object\n returns: The internal type of the enum type"]
    pub fn duckdb_enum_internal_type(type_: duckdb_logical_type) -> duckdb_type;
}
extern "C" {
    #[doc = "Retrieves the dictionary size of the enum type\n\n type: The logical type object\n returns: The dictionary size of the enum type"]
    pub fn duckdb_enum_dictionary_size(type_: duckdb_logical_type) -> u32;
}
extern "C" {
    #[doc = "Retrieves the dictionary value at the specified position from the enum.\n\nThe result must be freed with `duckdb_free`\n\n type: The logical type object\n index: The index in the dictionary\n returns: The string value of the enum type. Must be freed with `duckdb_free`."]
    pub fn duckdb_enum_dictionary_value(type_: duckdb_logical_type, index: idx_t) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    #[doc = "Retrieves the child type of the given list type.\n\nThe result must be freed with `duckdb_destroy_logical_type`\n\n type: The logical type object\n returns: The child type of the list type. Must be destroyed with `duckdb_destroy_logical_type`."]
    pub fn duckdb_list_type_child_type(type_: duckdb_logical_type) -> duckdb_logical_type;
}
extern "C" {
    #[doc = "Retrieves the key type of the given map type.\n\nThe result must be freed with `duckdb_destroy_logical_type`\n\n type: The logical type object\n returns: The key type of the map type. Must be destroyed with `duckdb_destroy_logical_type`."]
    pub fn duckdb_map_type_key_type(type_: duckdb_logical_type) -> duckdb_logical_type;
}
extern "C" {
    #[doc = "Retrieves the value type of the given map type.\n\nThe result must be freed with `duckdb_destroy_logical_type`\n\n type: The logical type object\n returns: The value type of the map type. Must be destroyed with `duckdb_destroy_logical_type`."]
    pub fn duckdb_map_type_value_type(type_: duckdb_logical_type) -> duckdb_logical_type;
}
extern "C" {
    #[doc = "Returns the number of children of a struct type.\n\n type: The logical type object\n returns: The number of children of a struct type."]
    pub fn duckdb_struct_type_child_count(type_: duckdb_logical_type) -> idx_t;
}
extern "C" {
    #[doc = "Retrieves the name of the struct child.\n\nThe result must be freed with `duckdb_free`\n\n type: The logical type object\n index: The child index\n returns: The name of the struct type. Must be freed with `duckdb_free`."]
    pub fn duckdb_struct_type_child_name(type_: duckdb_logical_type, index: idx_t) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    #[doc = "Retrieves the child type of the given struct type at the specified index.\n\nThe result must be freed with `duckdb_destroy_logical_type`\n\n type: The logical type object\n index: The child index\n returns: The child type of the struct type. Must be destroyed with `duckdb_destroy_logical_type`."]
    pub fn duckdb_struct_type_child_type(type_: duckdb_logical_type, index: idx_t) -> duckdb_logical_type;
}
extern "C" {
    #[doc = "Returns the number of members that the union type has.\n\n type: The logical type (union) object\n returns: The number of members of a union type."]
    pub fn duckdb_union_type_member_count(type_: duckdb_logical_type) -> idx_t;
}
extern "C" {
    #[doc = "Retrieves the name of the union member.\n\nThe result must be freed with `duckdb_free`\n\n type: The logical type object\n index: The child index\n returns: The name of the union member. Must be freed with `duckdb_free`."]
    pub fn duckdb_union_type_member_name(type_: duckdb_logical_type, index: idx_t) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    #[doc = "Retrieves the child type of the given union member at the specified index.\n\nThe result must be freed with `duckdb_destroy_logical_type`\n\n type: The logical type object\n index: The child index\n returns: The child type of the union member. Must be destroyed with `duckdb_destroy_logical_type`."]
    pub fn duckdb_union_type_member_type(type_: duckdb_logical_type, index: idx_t) -> duckdb_logical_type;
}
extern "C" {
    #[doc = "Destroys the logical type and de-allocates all memory allocated for that type.\n\n type: The logical type to destroy."]
    pub fn duckdb_destroy_logical_type(type_: *mut duckdb_logical_type);
}
extern "C" {
    #[doc = "Creates an empty DataChunk with the specified set of types.\n\n types: An array of types of the data chunk.\n column_count: The number of columns.\n returns: The data chunk."]
    pub fn duckdb_create_data_chunk(types: *mut duckdb_logical_type, column_count: idx_t) -> duckdb_data_chunk;
}
extern "C" {
    #[doc = "Destroys the data chunk and de-allocates all memory allocated for that chunk.\n\n chunk: The data chunk to destroy."]
    pub fn duckdb_destroy_data_chunk(chunk: *mut duckdb_data_chunk);
}
extern "C" {
    #[doc = "Resets a data chunk, clearing the validity masks and setting the cardinality of the data chunk to 0.\n\n chunk: The data chunk to reset."]
    pub fn duckdb_data_chunk_reset(chunk: duckdb_data_chunk);
}
extern "C" {
    #[doc = "Retrieves the number of columns in a data chunk.\n\n chunk: The data chunk to get the data from\n returns: The number of columns in the data chunk"]
    pub fn duckdb_data_chunk_get_column_count(chunk: duckdb_data_chunk) -> idx_t;
}
extern "C" {
    #[doc = "Retrieves the vector at the specified column index in the data chunk.\n\nThe pointer to the vector is valid for as long as the chunk is alive.\nIt does NOT need to be destroyed.\n\n chunk: The data chunk to get the data from\n returns: The vector"]
    pub fn duckdb_data_chunk_get_vector(chunk: duckdb_data_chunk, col_idx: idx_t) -> duckdb_vector;
}
extern "C" {
    #[doc = "Retrieves the current number of tuples in a data chunk.\n\n chunk: The data chunk to get the data from\n returns: The number of tuples in the data chunk"]
    pub fn duckdb_data_chunk_get_size(chunk: duckdb_data_chunk) -> idx_t;
}
extern "C" {
    #[doc = "Sets the current number of tuples in a data chunk.\n\n chunk: The data chunk to set the size in\n size: The number of tuples in the data chunk"]
    pub fn duckdb_data_chunk_set_size(chunk: duckdb_data_chunk, size: idx_t);
}
extern "C" {
    #[doc = "Retrieves the column type of the specified vector.\n\nThe result must be destroyed with `duckdb_destroy_logical_type`.\n\n vector: The vector get the data from\n returns: The type of the vector"]
    pub fn duckdb_vector_get_column_type(vector: duckdb_vector) -> duckdb_logical_type;
}
extern "C" {
    #[doc = "Retrieves the data pointer of the vector.\n\nThe data pointer can be used to read or write values from the vector.\nHow to read or write values depends on the type of the vector.\n\n vector: The vector to get the data from\n returns: The data pointer"]
    pub fn duckdb_vector_get_data(vector: duckdb_vector) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    #[doc = "Retrieves the validity mask pointer of the specified vector.\n\nIf all values are valid, this function MIGHT return NULL!\n\nThe validity mask is a bitset that signifies null-ness within the data chunk.\nIt is a series of uint64_t values, where each uint64_t value contains validity for 64 tuples.\nThe bit is set to 1 if the value is valid (i.e. not NULL) or 0 if the value is invalid (i.e. NULL).\n\nValidity of a specific value can be obtained like this:\n\nidx_t entry_idx = row_idx / 64;\nidx_t idx_in_entry = row_idx % 64;\nbool is_valid = validity_mask[entry_idx] & (1 << idx_in_entry);\n\nAlternatively, the (slower) duckdb_validity_row_is_valid function can be used.\n\n vector: The vector to get the data from\n returns: The pointer to the validity mask, or NULL if no validity mask is present"]
    pub fn duckdb_vector_get_validity(vector: duckdb_vector) -> *mut u64;
}
extern "C" {
    #[doc = "Ensures the validity mask is writable by allocating it.\n\nAfter this function is called, `duckdb_vector_get_validity` will ALWAYS return non-NULL.\nThis allows null values to be written to the vector, regardless of whether a validity mask was present before.\n\n vector: The vector to alter"]
    pub fn duckdb_vector_ensure_validity_writable(vector: duckdb_vector);
}
extern "C" {
    #[doc = "Assigns a string element in the vector at the specified location.\n\n vector: The vector to alter\n index: The row position in the vector to assign the string to\n str: The null-terminated string"]
    pub fn duckdb_vector_assign_string_element(
        vector: duckdb_vector,
        index: idx_t,
        str_: *const ::std::os::raw::c_char,
    );
}
extern "C" {
    #[doc = "Assigns a string element in the vector at the specified location.\n\n vector: The vector to alter\n index: The row position in the vector to assign the string to\n str: The string\n str_len: The length of the string (in bytes)"]
    pub fn duckdb_vector_assign_string_element_len(
        vector: duckdb_vector,
        index: idx_t,
        str_: *const ::std::os::raw::c_char,
        str_len: idx_t,
    );
}
extern "C" {
    #[doc = "Retrieves the child vector of a list vector.\n\nThe resulting vector is valid as long as the parent vector is valid.\n\n vector: The vector\n returns: The child vector"]
    pub fn duckdb_list_vector_get_child(vector: duckdb_vector) -> duckdb_vector;
}
extern "C" {
    #[doc = "Returns the size of the child vector of the list\n\n vector: The vector\n returns: The size of the child list"]
    pub fn duckdb_list_vector_get_size(vector: duckdb_vector) -> idx_t;
}
extern "C" {
    #[doc = "Sets the total size of the underlying child-vector of a list vector.\n\n vector: The list vector.\n size: The size of the child list.\n returns: The duckdb state. Returns DuckDBError if the vector is nullptr."]
    pub fn duckdb_list_vector_set_size(vector: duckdb_vector, size: idx_t) -> duckdb_state;
}
extern "C" {
    #[doc = "Sets the total capacity of the underlying child-vector of a list.\n\n vector: The list vector.\n required_capacity: the total capacity to reserve.\n return: The duckdb state. Returns DuckDBError if the vector is nullptr."]
    pub fn duckdb_list_vector_reserve(vector: duckdb_vector, required_capacity: idx_t) -> duckdb_state;
}
extern "C" {
    #[doc = "Retrieves the child vector of a struct vector.\n\nThe resulting vector is valid as long as the parent vector is valid.\n\n vector: The vector\n index: The child index\n returns: The child vector"]
    pub fn duckdb_struct_vector_get_child(vector: duckdb_vector, index: idx_t) -> duckdb_vector;
}
extern "C" {
    #[doc = "Returns whether or not a row is valid (i.e. not NULL) in the given validity mask.\n\n validity: The validity mask, as obtained through `duckdb_data_chunk_get_validity`\n row: The row index\n returns: true if the row is valid, false otherwise"]
    pub fn duckdb_validity_row_is_valid(validity: *mut u64, row: idx_t) -> bool;
}
extern "C" {
    #[doc = "In a validity mask, sets a specific row to either valid or invalid.\n\nNote that `duckdb_data_chunk_ensure_validity_writable` should be called before calling `duckdb_data_chunk_get_validity`,\nto ensure that there is a validity mask to write to.\n\n validity: The validity mask, as obtained through `duckdb_data_chunk_get_validity`.\n row: The row index\n valid: Whether or not to set the row to valid, or invalid"]
    pub fn duckdb_validity_set_row_validity(validity: *mut u64, row: idx_t, valid: bool);
}
extern "C" {
    #[doc = "In a validity mask, sets a specific row to invalid.\n\nEquivalent to `duckdb_validity_set_row_validity` with valid set to false.\n\n validity: The validity mask\n row: The row index"]
    pub fn duckdb_validity_set_row_invalid(validity: *mut u64, row: idx_t);
}
extern "C" {
    #[doc = "In a validity mask, sets a specific row to valid.\n\nEquivalent to `duckdb_validity_set_row_validity` with valid set to true.\n\n validity: The validity mask\n row: The row index"]
    pub fn duckdb_validity_set_row_valid(validity: *mut u64, row: idx_t);
}
pub type duckdb_table_function = *mut ::std::os::raw::c_void;
pub type duckdb_bind_info = *mut ::std::os::raw::c_void;
pub type duckdb_init_info = *mut ::std::os::raw::c_void;
pub type duckdb_function_info = *mut ::std::os::raw::c_void;
pub type duckdb_table_function_bind_t = ::std::option::Option<unsafe extern "C" fn(info: duckdb_bind_info)>;
pub type duckdb_table_function_init_t = ::std::option::Option<unsafe extern "C" fn(info: duckdb_init_info)>;
pub type duckdb_table_function_t =
    ::std::option::Option<unsafe extern "C" fn(info: duckdb_function_info, output: duckdb_data_chunk)>;
pub type duckdb_delete_callback_t = ::std::option::Option<unsafe extern "C" fn(data: *mut ::std::os::raw::c_void)>;
extern "C" {
    #[doc = "Creates a new empty table function.\n\nThe return value should be destroyed with `duckdb_destroy_table_function`.\n\n returns: The table function object."]
    pub fn duckdb_create_table_function() -> duckdb_table_function;
}
extern "C" {
    #[doc = "Destroys the given table function object.\n\n table_function: The table function to destroy"]
    pub fn duckdb_destroy_table_function(table_function: *mut duckdb_table_function);
}
extern "C" {
    #[doc = "Sets the name of the given table function.\n\n table_function: The table function\n name: The name of the table function"]
    pub fn duckdb_table_function_set_name(table_function: duckdb_table_function, name: *const ::std::os::raw::c_char);
}
extern "C" {
    #[doc = "Adds a parameter to the table function.\n\n table_function: The table function\n type: The type of the parameter to add."]
    pub fn duckdb_table_function_add_parameter(table_function: duckdb_table_function, type_: duckdb_logical_type);
}
extern "C" {
    #[doc = "Adds a named parameter to the table function.\n\n table_function: The table function\n name: The name of the parameter\n type: The type of the parameter to add."]
    pub fn duckdb_table_function_add_named_parameter(
        table_function: duckdb_table_function,
        name: *const ::std::os::raw::c_char,
        type_: duckdb_logical_type,
    );
}
extern "C" {
    #[doc = "Assigns extra information to the table function that can be fetched during binding, etc.\n\n table_function: The table function\n extra_info: The extra information\n destroy: The callback that will be called to destroy the bind data (if any)"]
    pub fn duckdb_table_function_set_extra_info(
        table_function: duckdb_table_function,
        extra_info: *mut ::std::os::raw::c_void,
        destroy: duckdb_delete_callback_t,
    );
}
extern "C" {
    #[doc = "Sets the bind function of the table function\n\n table_function: The table function\n bind: The bind function"]
    pub fn duckdb_table_function_set_bind(table_function: duckdb_table_function, bind: duckdb_table_function_bind_t);
}
extern "C" {
    #[doc = "Sets the init function of the table function\n\n table_function: The table function\n init: The init function"]
    pub fn duckdb_table_function_set_init(table_function: duckdb_table_function, init: duckdb_table_function_init_t);
}
extern "C" {
    #[doc = "Sets the thread-local init function of the table function\n\n table_function: The table function\n init: The init function"]
    pub fn duckdb_table_function_set_local_init(
        table_function: duckdb_table_function,
        init: duckdb_table_function_init_t,
    );
}
extern "C" {
    #[doc = "Sets the main function of the table function\n\n table_function: The table function\n function: The function"]
    pub fn duckdb_table_function_set_function(table_function: duckdb_table_function, function: duckdb_table_function_t);
}
extern "C" {
    #[doc = "Sets whether or not the given table function supports projection pushdown.\n\nIf this is set to true, the system will provide a list of all required columns in the `init` stage through\nthe `duckdb_init_get_column_count` and `duckdb_init_get_column_index` functions.\nIf this is set to false (the default), the system will expect all columns to be projected.\n\n table_function: The table function\n pushdown: True if the table function supports projection pushdown, false otherwise."]
    pub fn duckdb_table_function_supports_projection_pushdown(table_function: duckdb_table_function, pushdown: bool);
}
extern "C" {
    #[doc = "Register the table function object within the given connection.\n\nThe function requires at least a name, a bind function, an init function and a main function.\n\nIf the function is incomplete or a function with this name already exists DuckDBError is returned.\n\n con: The connection to register it in.\n function: The function pointer\n returns: Whether or not the registration was successful."]
    pub fn duckdb_register_table_function(con: duckdb_connection, function: duckdb_table_function) -> duckdb_state;
}
extern "C" {
    #[doc = "Retrieves the extra info of the function as set in `duckdb_table_function_set_extra_info`\n\n info: The info object\n returns: The extra info"]
    pub fn duckdb_bind_get_extra_info(info: duckdb_bind_info) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    #[doc = "Adds a result column to the output of the table function.\n\n info: The info object\n name: The name of the column\n type: The logical type of the column"]
    pub fn duckdb_bind_add_result_column(
        info: duckdb_bind_info,
        name: *const ::std::os::raw::c_char,
        type_: duckdb_logical_type,
    );
}
extern "C" {
    #[doc = "Retrieves the number of regular (non-named) parameters to the function.\n\n info: The info object\n returns: The number of parameters"]
    pub fn duckdb_bind_get_parameter_count(info: duckdb_bind_info) -> idx_t;
}
extern "C" {
    #[doc = "Retrieves the parameter at the given index.\n\nThe result must be destroyed with `duckdb_destroy_value`.\n\n info: The info object\n index: The index of the parameter to get\n returns: The value of the parameter. Must be destroyed with `duckdb_destroy_value`."]
    pub fn duckdb_bind_get_parameter(info: duckdb_bind_info, index: idx_t) -> duckdb_value;
}
extern "C" {
    #[doc = "Retrieves a named parameter with the given name.\n\nThe result must be destroyed with `duckdb_destroy_value`.\n\n info: The info object\n name: The name of the parameter\n returns: The value of the parameter. Must be destroyed with `duckdb_destroy_value`."]
    pub fn duckdb_bind_get_named_parameter(info: duckdb_bind_info, name: *const ::std::os::raw::c_char)
        -> duckdb_value;
}
extern "C" {
    #[doc = "Sets the user-provided bind data in the bind object. This object can be retrieved again during execution.\n\n info: The info object\n extra_data: The bind data object.\n destroy: The callback that will be called to destroy the bind data (if any)"]
    pub fn duckdb_bind_set_bind_data(
        info: duckdb_bind_info,
        bind_data: *mut ::std::os::raw::c_void,
        destroy: duckdb_delete_callback_t,
    );
}
extern "C" {
    #[doc = "Sets the cardinality estimate for the table function, used for optimization.\n\n info: The bind data object.\n is_exact: Whether or not the cardinality estimate is exact, or an approximation"]
    pub fn duckdb_bind_set_cardinality(info: duckdb_bind_info, cardinality: idx_t, is_exact: bool);
}
extern "C" {
    #[doc = "Report that an error has occurred while calling bind.\n\n info: The info object\n error: The error message"]
    pub fn duckdb_bind_set_error(info: duckdb_bind_info, error: *const ::std::os::raw::c_char);
}
extern "C" {
    #[doc = "Retrieves the extra info of the function as set in `duckdb_table_function_set_extra_info`\n\n info: The info object\n returns: The extra info"]
    pub fn duckdb_init_get_extra_info(info: duckdb_init_info) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    #[doc = "Gets the bind data set by `duckdb_bind_set_bind_data` during the bind.\n\nNote that the bind data should be considered as read-only.\nFor tracking state, use the init data instead.\n\n info: The info object\n returns: The bind data object"]
    pub fn duckdb_init_get_bind_data(info: duckdb_init_info) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    #[doc = "Sets the user-provided init data in the init object. This object can be retrieved again during execution.\n\n info: The info object\n extra_data: The init data object.\n destroy: The callback that will be called to destroy the init data (if any)"]
    pub fn duckdb_init_set_init_data(
        info: duckdb_init_info,
        init_data: *mut ::std::os::raw::c_void,
        destroy: duckdb_delete_callback_t,
    );
}
extern "C" {
    #[doc = "Returns the number of projected columns.\n\nThis function must be used if projection pushdown is enabled to figure out which columns to emit.\n\n info: The info object\n returns: The number of projected columns."]
    pub fn duckdb_init_get_column_count(info: duckdb_init_info) -> idx_t;
}
extern "C" {
    #[doc = "Returns the column index of the projected column at the specified position.\n\nThis function must be used if projection pushdown is enabled to figure out which columns to emit.\n\n info: The info object\n column_index: The index at which to get the projected column index, from 0..duckdb_init_get_column_count(info)\n returns: The column index of the projected column."]
    pub fn duckdb_init_get_column_index(info: duckdb_init_info, column_index: idx_t) -> idx_t;
}
extern "C" {
    #[doc = "Sets how many threads can process this table function in parallel (default: 1)\n\n info: The info object\n max_threads: The maximum amount of threads that can process this table function"]
    pub fn duckdb_init_set_max_threads(info: duckdb_init_info, max_threads: idx_t);
}
extern "C" {
    #[doc = "Report that an error has occurred while calling init.\n\n info: The info object\n error: The error message"]
    pub fn duckdb_init_set_error(info: duckdb_init_info, error: *const ::std::os::raw::c_char);
}
extern "C" {
    #[doc = "Retrieves the extra info of the function as set in `duckdb_table_function_set_extra_info`\n\n info: The info object\n returns: The extra info"]
    pub fn duckdb_function_get_extra_info(info: duckdb_function_info) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    #[doc = "Gets the bind data set by `duckdb_bind_set_bind_data` during the bind.\n\nNote that the bind data should be considered as read-only.\nFor tracking state, use the init data instead.\n\n info: The info object\n returns: The bind data object"]
    pub fn duckdb_function_get_bind_data(info: duckdb_function_info) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    #[doc = "Gets the init data set by `duckdb_init_set_init_data` during the init.\n\n info: The info object\n returns: The init data object"]
    pub fn duckdb_function_get_init_data(info: duckdb_function_info) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    #[doc = "Gets the thread-local init data set by `duckdb_init_set_init_data` during the local_init.\n\n info: The info object\n returns: The init data object"]
    pub fn duckdb_function_get_local_init_data(info: duckdb_function_info) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    #[doc = "Report that an error has occurred while executing the function.\n\n info: The info object\n error: The error message"]
    pub fn duckdb_function_set_error(info: duckdb_function_info, error: *const ::std::os::raw::c_char);
}
pub type duckdb_replacement_scan_info = *mut ::std::os::raw::c_void;
pub type duckdb_replacement_callback_t = ::std::option::Option<
    unsafe extern "C" fn(
        info: duckdb_replacement_scan_info,
        table_name: *const ::std::os::raw::c_char,
        data: *mut ::std::os::raw::c_void,
    ),
>;
extern "C" {
    #[doc = "Add a replacement scan definition to the specified database\n\n db: The database object to add the replacement scan to\n replacement: The replacement scan callback\n extra_data: Extra data that is passed back into the specified callback\n delete_callback: The delete callback to call on the extra data, if any"]
    pub fn duckdb_add_replacement_scan(
        db: duckdb_database,
        replacement: duckdb_replacement_callback_t,
        extra_data: *mut ::std::os::raw::c_void,
        delete_callback: duckdb_delete_callback_t,
    );
}
extern "C" {
    #[doc = "Sets the replacement function name to use. If this function is called in the replacement callback,\nthe replacement scan is performed. If it is not called, the replacement callback is not performed.\n\n info: The info object\n function_name: The function name to substitute."]
    pub fn duckdb_replacement_scan_set_function_name(
        info: duckdb_replacement_scan_info,
        function_name: *const ::std::os::raw::c_char,
    );
}
extern "C" {
    #[doc = "Adds a parameter to the replacement scan function.\n\n info: The info object\n parameter: The parameter to add."]
    pub fn duckdb_replacement_scan_add_parameter(info: duckdb_replacement_scan_info, parameter: duckdb_value);
}
extern "C" {
    #[doc = "Report that an error has occurred while executing the replacement scan.\n\n info: The info object\n error: The error message"]
    pub fn duckdb_replacement_scan_set_error(info: duckdb_replacement_scan_info, error: *const ::std::os::raw::c_char);
}
extern "C" {
    #[doc = "Creates an appender object.\n\n connection: The connection context to create the appender in.\n schema: The schema of the table to append to, or `nullptr` for the default schema.\n table: The table name to append to.\n out_appender: The resulting appender object.\n returns: `DuckDBSuccess` on success or `DuckDBError` on failure."]
    pub fn duckdb_appender_create(
        connection: duckdb_connection,
        schema: *const ::std::os::raw::c_char,
        table: *const ::std::os::raw::c_char,
        out_appender: *mut duckdb_appender,
    ) -> duckdb_state;
}
extern "C" {
    #[doc = "Returns the error message associated with the given appender.\nIf the appender has no error message, this returns `nullptr` instead.\n\nThe error message should not be freed. It will be de-allocated when `duckdb_appender_destroy` is called.\n\n appender: The appender to get the error from.\n returns: The error message, or `nullptr` if there is none."]
    pub fn duckdb_appender_error(appender: duckdb_appender) -> *const ::std::os::raw::c_char;
}
extern "C" {
    #[doc = "Flush the appender to the table, forcing the cache of the appender to be cleared and the data to be appended to the\nbase table.\n\nThis should generally not be used unless you know what you are doing. Instead, call `duckdb_appender_destroy` when you\nare done with the appender.\n\n appender: The appender to flush.\n returns: `DuckDBSuccess` on success or `DuckDBError` on failure."]
    pub fn duckdb_appender_flush(appender: duckdb_appender) -> duckdb_state;
}
extern "C" {
    #[doc = "Close the appender, flushing all intermediate state in the appender to the table and closing it for further appends.\n\nThis is generally not necessary. Call `duckdb_appender_destroy` instead.\n\n appender: The appender to flush and close.\n returns: `DuckDBSuccess` on success or `DuckDBError` on failure."]
    pub fn duckdb_appender_close(appender: duckdb_appender) -> duckdb_state;
}
extern "C" {
    #[doc = "Close the appender and destroy it. Flushing all intermediate state in the appender to the table, and de-allocating\nall memory associated with the appender.\n\n appender: The appender to flush, close and destroy.\n returns: `DuckDBSuccess` on success or `DuckDBError` on failure."]
    pub fn duckdb_appender_destroy(appender: *mut duckdb_appender) -> duckdb_state;
}
extern "C" {
    #[doc = "A nop function, provided for backwards compatibility reasons. Does nothing. Only `duckdb_appender_end_row` is required."]
    pub fn duckdb_appender_begin_row(appender: duckdb_appender) -> duckdb_state;
}
extern "C" {
    #[doc = "Finish the current row of appends. After end_row is called, the next row can be appended.\n\n appender: The appender.\n returns: `DuckDBSuccess` on success or `DuckDBError` on failure."]
    pub fn duckdb_appender_end_row(appender: duckdb_appender) -> duckdb_state;
}
extern "C" {
    #[doc = "Append a bool value to the appender."]
    pub fn duckdb_append_bool(appender: duckdb_appender, value: bool) -> duckdb_state;
}
extern "C" {
    #[doc = "Append an int8_t value to the appender."]
    pub fn duckdb_append_int8(appender: duckdb_appender, value: i8) -> duckdb_state;
}
extern "C" {
    #[doc = "Append an int16_t value to the appender."]
    pub fn duckdb_append_int16(appender: duckdb_appender, value: i16) -> duckdb_state;
}
extern "C" {
    #[doc = "Append an int32_t value to the appender."]
    pub fn duckdb_append_int32(appender: duckdb_appender, value: i32) -> duckdb_state;
}
extern "C" {
    #[doc = "Append an int64_t value to the appender."]
    pub fn duckdb_append_int64(appender: duckdb_appender, value: i64) -> duckdb_state;
}
extern "C" {
    #[doc = "Append a duckdb_hugeint value to the appender."]
    pub fn duckdb_append_hugeint(appender: duckdb_appender, value: duckdb_hugeint) -> duckdb_state;
}
extern "C" {
    #[doc = "Append a uint8_t value to the appender."]
    pub fn duckdb_append_uint8(appender: duckdb_appender, value: u8) -> duckdb_state;
}
extern "C" {
    #[doc = "Append a uint16_t value to the appender."]
    pub fn duckdb_append_uint16(appender: duckdb_appender, value: u16) -> duckdb_state;
}
extern "C" {
    #[doc = "Append a uint32_t value to the appender."]
    pub fn duckdb_append_uint32(appender: duckdb_appender, value: u32) -> duckdb_state;
}
extern "C" {
    #[doc = "Append a uint64_t value to the appender."]
    pub fn duckdb_append_uint64(appender: duckdb_appender, value: u64) -> duckdb_state;
}
extern "C" {
    #[doc = "Append a float value to the appender."]
    pub fn duckdb_append_float(appender: duckdb_appender, value: f32) -> duckdb_state;
}
extern "C" {
    #[doc = "Append a double value to the appender."]
    pub fn duckdb_append_double(appender: duckdb_appender, value: f64) -> duckdb_state;
}
extern "C" {
    #[doc = "Append a duckdb_date value to the appender."]
    pub fn duckdb_append_date(appender: duckdb_appender, value: duckdb_date) -> duckdb_state;
}
extern "C" {
    #[doc = "Append a duckdb_time value to the appender."]
    pub fn duckdb_append_time(appender: duckdb_appender, value: duckdb_time) -> duckdb_state;
}
extern "C" {
    #[doc = "Append a duckdb_timestamp value to the appender."]
    pub fn duckdb_append_timestamp(appender: duckdb_appender, value: duckdb_timestamp) -> duckdb_state;
}
extern "C" {
    #[doc = "Append a duckdb_interval value to the appender."]
    pub fn duckdb_append_interval(appender: duckdb_appender, value: duckdb_interval) -> duckdb_state;
}
extern "C" {
    #[doc = "Append a varchar value to the appender."]
    pub fn duckdb_append_varchar(appender: duckdb_appender, val: *const ::std::os::raw::c_char) -> duckdb_state;
}
extern "C" {
    #[doc = "Append a varchar value to the appender."]
    pub fn duckdb_append_varchar_length(
        appender: duckdb_appender,
        val: *const ::std::os::raw::c_char,
        length: idx_t,
    ) -> duckdb_state;
}
extern "C" {
    #[doc = "Append a blob value to the appender."]
    pub fn duckdb_append_blob(
        appender: duckdb_appender,
        data: *const ::std::os::raw::c_void,
        length: idx_t,
    ) -> duckdb_state;
}
extern "C" {
    #[doc = "Append a NULL value to the appender (of any type)."]
    pub fn duckdb_append_null(appender: duckdb_appender) -> duckdb_state;
}
extern "C" {
    #[doc = "Appends a pre-filled data chunk to the specified appender.\n\nThe types of the data chunk must exactly match the types of the table, no casting is performed.\nIf the types do not match or the appender is in an invalid state, DuckDBError is returned.\nIf the append is successful, DuckDBSuccess is returned.\n\n appender: The appender to append to.\n chunk: The data chunk to append.\n returns: The return state."]
    pub fn duckdb_append_data_chunk(appender: duckdb_appender, chunk: duckdb_data_chunk) -> duckdb_state;
}
extern "C" {
    #[doc = "Executes a SQL query within a connection and stores the full (materialized) result in an arrow structure.\nIf the query fails to execute, DuckDBError is returned and the error message can be retrieved by calling\n`duckdb_query_arrow_error`.\n\nNote that after running `duckdb_query_arrow`, `duckdb_destroy_arrow` must be called on the result object even if the\nquery fails, otherwise the error stored within the result will not be freed correctly.\n\n connection: The connection to perform the query in.\n query: The SQL query to run.\n out_result: The query result.\n returns: `DuckDBSuccess` on success or `DuckDBError` on failure."]
    pub fn duckdb_query_arrow(
        connection: duckdb_connection,
        query: *const ::std::os::raw::c_char,
        out_result: *mut duckdb_arrow,
    ) -> duckdb_state;
}
extern "C" {
    #[doc = "Fetch the internal arrow schema from the arrow result.\n\n result: The result to fetch the schema from.\n out_schema: The output schema.\n returns: `DuckDBSuccess` on success or `DuckDBError` on failure."]
    pub fn duckdb_query_arrow_schema(result: duckdb_arrow, out_schema: *mut duckdb_arrow_schema) -> duckdb_state;
}
extern "C" {
    #[doc = "Fetch an internal arrow array from the arrow result.\n\nThis function can be called multiple time to get next chunks, which will free the previous out_array.\nSo consume the out_array before calling this function again.\n\n result: The result to fetch the array from.\n out_array: The output array.\n returns: `DuckDBSuccess` on success or `DuckDBError` on failure."]
    pub fn duckdb_query_arrow_array(result: duckdb_arrow, out_array: *mut duckdb_arrow_array) -> duckdb_state;
}
extern "C" {
    #[doc = "Returns the number of columns present in a the arrow result object.\n\n result: The result object.\n returns: The number of columns present in the result object."]
    pub fn duckdb_arrow_column_count(result: duckdb_arrow) -> idx_t;
}
extern "C" {
    #[doc = "Returns the number of rows present in a the arrow result object.\n\n result: The result object.\n returns: The number of rows present in the result object."]
    pub fn duckdb_arrow_row_count(result: duckdb_arrow) -> idx_t;
}
extern "C" {
    #[doc = "Returns the number of rows changed by the query stored in the arrow result. This is relevant only for\nINSERT/UPDATE/DELETE queries. For other queries the rows_changed will be 0.\n\n result: The result object.\n returns: The number of rows changed."]
    pub fn duckdb_arrow_rows_changed(result: duckdb_arrow) -> idx_t;
}
extern "C" {
    #[doc = "Returns the error message contained within the result. The error is only set if `duckdb_query_arrow` returns\n`DuckDBError`.\n\nThe error message should not be freed. It will be de-allocated when `duckdb_destroy_arrow` is called.\n\n result: The result object to fetch the nullmask from.\n returns: The error of the result."]
    pub fn duckdb_query_arrow_error(result: duckdb_arrow) -> *const ::std::os::raw::c_char;
}
extern "C" {
    #[doc = "Closes the result and de-allocates all memory allocated for the arrow result.\n\n result: The result to destroy."]
    pub fn duckdb_destroy_arrow(result: *mut duckdb_arrow);
}
pub type duckdb_task_state = *mut ::std::os::raw::c_void;
extern "C" {
    #[doc = "Execute DuckDB tasks on this thread.\n\nWill return after `max_tasks` have been executed, or if there are no more tasks present.\n\n database: The database object to execute tasks for\n max_tasks: The maximum amount of tasks to execute"]
    pub fn duckdb_execute_tasks(database: duckdb_database, max_tasks: idx_t);
}
extern "C" {
    #[doc = "Creates a task state that can be used with duckdb_execute_tasks_state to execute tasks until\nduckdb_finish_execution is called on the state.\n\nduckdb_destroy_state should be called on the result in order to free memory.\n\n database: The database object to create the task state for\n returns: The task state that can be used with duckdb_execute_tasks_state."]
    pub fn duckdb_create_task_state(database: duckdb_database) -> duckdb_task_state;
}
extern "C" {
    #[doc = "Execute DuckDB tasks on this thread.\n\nThe thread will keep on executing tasks forever, until duckdb_finish_execution is called on the state.\nMultiple threads can share the same duckdb_task_state.\n\n state: The task state of the executor"]
    pub fn duckdb_execute_tasks_state(state: duckdb_task_state);
}
extern "C" {
    #[doc = "Execute DuckDB tasks on this thread.\n\nThe thread will keep on executing tasks until either duckdb_finish_execution is called on the state,\nmax_tasks tasks have been executed or there are no more tasks to be executed.\n\nMultiple threads can share the same duckdb_task_state.\n\n state: The task state of the executor\n max_tasks: The maximum amount of tasks to execute\n returns: The amount of tasks that have actually been executed"]
    pub fn duckdb_execute_n_tasks_state(state: duckdb_task_state, max_tasks: idx_t) -> idx_t;
}
extern "C" {
    #[doc = "Finish execution on a specific task.\n\n state: The task state to finish execution"]
    pub fn duckdb_finish_execution(state: duckdb_task_state);
}
extern "C" {
    #[doc = "Check if the provided duckdb_task_state has finished execution\n\n state: The task state to inspect\n returns: Whether or not duckdb_finish_execution has been called on the task state"]
    pub fn duckdb_task_state_is_finished(state: duckdb_task_state) -> bool;
}
extern "C" {
    #[doc = "Destroys the task state returned from duckdb_create_task_state.\n\nNote that this should not be called while there is an active duckdb_execute_tasks_state running\non the task state.\n\n state: The task state to clean up"]
    pub fn duckdb_destroy_task_state(state: duckdb_task_state);
}
extern "C" {
    #[doc = "Returns true if execution of the current query is finished.\n\n con: The connection on which to check"]
    pub fn duckdb_execution_is_finished(con: duckdb_connection) -> bool;
}
extern "C" {
    #[doc = "Fetches a data chunk from the (streaming) duckdb_result. This function should be called repeatedly until the result is\nexhausted.\n\nThe result must be destroyed with `duckdb_destroy_data_chunk`.\n\nThis function can only be used on duckdb_results created with 'duckdb_pending_prepared_streaming'\n\nIf this function is used, none of the other result functions can be used and vice versa (i.e. this function cannot be\nmixed with the legacy result functions or the materialized result functions).\n\nIt is not known beforehand how many chunks will be returned by this result.\n\n result: The result object to fetch the data chunk from.\n returns: The resulting data chunk. Returns `NULL` if the result has an error."]
    pub fn duckdb_stream_fetch_chunk(result: duckdb_result) -> duckdb_data_chunk;
}
